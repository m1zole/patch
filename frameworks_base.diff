diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index ced5e1f56402..d1694013ae52 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -830,97 +830,8 @@ public class ApplicationPackageManager extends PackageManager {
                 }
             };
 
-    private static final String[] pTensorCodenames = {
-            "husky",
-            "shiba",
-            "felix",
-            "tangorpro",
-            "lynx",
-            "cheetah",
-            "panther",
-            "bluejay",
-            "oriole",
-            "raven"
-    };
-
-    private static final String[] featuresPixel = {
-            "com.google.android.apps.photos.PIXEL_2019_PRELOAD",
-            "com.google.android.apps.photos.PIXEL_2019_MIDYEAR_PRELOAD",
-            "com.google.android.apps.photos.PIXEL_2018_PRELOAD",
-            "com.google.android.apps.photos.PIXEL_2017_PRELOAD",
-            "com.google.android.feature.PIXEL_2020_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2020_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2019_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2019_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2018_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2017_EXPERIENCE",
-            "com.google.android.feature.PIXEL_EXPERIENCE",
-            "com.google.android.feature.GOOGLE_BUILD",
-            "com.google.android.feature.GOOGLE_EXPERIENCE"
-    };
-
-    private static final String[] featuresPixelOthers = {
-            "com.google.android.feature.ASI",
-            "com.google.android.feature.ANDROID_ONE_EXPERIENCE",
-            "com.google.android.feature.GOOGLE_FI_BUNDLED",
-            "com.google.android.feature.LILY_EXPERIENCE",
-            "com.google.android.feature.TURBO_PRELOAD",
-            "com.google.android.feature.WELLBEING",
-            "com.google.lens.feature.IMAGE_INTEGRATION",
-            "com.google.lens.feature.CAMERA_INTEGRATION",
-            "com.google.photos.trust_debug_certs",
-            "com.google.android.feature.AER_OPTIMIZED",
-            "com.google.android.feature.NEXT_GENERATION_ASSISTANT",
-            "android.software.game_service",
-            "com.google.android.feature.EXCHANGE_6_2",
-            "com.google.android.apps.dialer.call_recording_audio",
-            "com.google.android.apps.dialer.SUPPORTED"
-    };
-
-    private static final String[] featuresP23 = {
-            "com.google.android.feature.PIXEL_2024_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2024_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2023_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2023_MIDYEAR_EXPERIENCE"
-    };
-
-    private static final String[] featuresTensor = {
-            "com.google.android.feature.PIXEL_2022_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2022_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2021_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2021_MIDYEAR_EXPERIENCE"
-    };
-
-    private static final String[] featuresNexus = {
-            "com.google.android.apps.photos.NEXUS_PRELOAD",
-            "com.google.android.apps.photos.nexus_preload",
-            "com.google.android.feature.PIXEL_EXPERIENCE",
-            "com.google.android.feature.GOOGLE_BUILD",
-            "com.google.android.feature.GOOGLE_EXPERIENCE"
-    };
-
     @Override
     public boolean hasSystemFeature(String name, int version) {
-        String packageName = ActivityThread.currentPackageName();
-        if (packageName != null &&
-                packageName.equals("com.google.android.apps.photos") &&
-                SystemProperties.getBoolean("persist.sys.pixelprops.gphotos", true)) {
-            if (Arrays.asList(featuresPixel).contains(name)) return false;
-            if (Arrays.asList(featuresPixelOthers).contains(name)) return true;
-            if (Arrays.asList(featuresP23).contains(name)) return false;
-            if (Arrays.asList(featuresTensor).contains(name)) return false;
-            if (Arrays.asList(featuresNexus).contains(name)) return true;
-        }
-        if (Arrays.asList(featuresTensor).contains(name) &&
-                !Arrays.asList(pTensorCodenames).contains(SystemProperties.get("ro.product.device"))) {
-            return false;
-        } else if (packageName != null && Arrays.asList(featuresTensor).contains(name)) {
-            if (packageName.contains("com.google.android.apps.nexuslauncher")) {
-                return false;
-            }
-        }
-        if (Arrays.asList(featuresPixel).contains(name)) return true;
-        if (Arrays.asList(featuresPixelOthers).contains(name)) return true;
         return mHasSystemFeatureCache.query(new HasSystemFeatureQuery(name, version));
     }
 
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index f32dc19c986c..2162e3a77f15 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -71,8 +71,6 @@ import java.util.Objects;
 import java.util.StringJoiner;
 import java.util.concurrent.TimeoutException;
 
-import com.android.internal.util.crdroid.PixelPropsUtils;
-
 /**
  * Base class for implementing application instrumentation code.  When running
  * with instrumentation turned on, this class will be instantiated for you
@@ -1346,8 +1344,6 @@ public class Instrumentation {
         Application app = getFactory(context.getPackageName())
                 .instantiateApplication(cl, className);
         app.attach(context);
-        String packageName = context.getPackageName();
-        PixelPropsUtils.setProps(packageName);
         return app;
     }
     
@@ -1365,8 +1361,6 @@ public class Instrumentation {
             ClassNotFoundException {
         Application app = (Application)clazz.newInstance();
         app.attach(context);
-        String packageName = context.getPackageName();
-        PixelPropsUtils.setProps(packageName);
         return app;
     }
 
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index f6e2fbaa6b2e..4dd355435ecd 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -118,8 +118,6 @@ import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 
-import com.android.internal.util.crdroid.DeviceConfigUtils;
-
 /**
  * The Settings provider contains global system-level device preferences.
  */
@@ -20948,9 +20946,6 @@ public final class Settings {
         @RequiresPermission(Manifest.permission.WRITE_DEVICE_CONFIG)
         public static boolean putString(@NonNull String namespace,
                 @NonNull String name, @Nullable String value, boolean makeDefault) {
-            if (DeviceConfigUtils.shouldDenyDeviceConfigControl(namespace, name)) {
-                return true;
-            }
             ContentResolver resolver = getContentResolver();
             return sNameValueCache.putStringForUser(resolver, createCompositeName(namespace, name),
                     value, null, makeDefault, resolver.getUserId(),
@@ -20972,9 +20967,7 @@ public final class Settings {
         public static boolean setStrings(@NonNull String namespace,
                 @NonNull Map<String, String> keyValues)
                 throws DeviceConfig.BadConfigException {
-            boolean result = setStrings(getContentResolver(), namespace, keyValues);
-            DeviceConfigUtils.setDefaultProperties(namespace, null);
-            return result;
+            return setStrings(getContentResolver(), namespace, keyValues);
         }
 
         /**
@@ -21024,9 +21017,6 @@ public final class Settings {
         @RequiresPermission(Manifest.permission.WRITE_DEVICE_CONFIG)
         public static boolean deleteString(@NonNull String namespace,
                 @NonNull String name) {
-            if (DeviceConfigUtils.shouldDenyDeviceConfigControl(namespace, name)) {
-                return true;
-            }
             ContentResolver resolver = getContentResolver();
             return sNameValueCache.deleteStringForUser(resolver,
                     createCompositeName(namespace, name), resolver.getUserId());
@@ -21063,7 +21053,6 @@ public final class Settings {
             } catch (RemoteException e) {
                 Log.w(TAG, "Can't reset to defaults for " + CONTENT_URI, e);
             }
-            DeviceConfigUtils.setDefaultProperties(null, null);
         }
 
         /**
diff --git a/core/java/com/android/internal/util/crdroid/DeviceConfigUtils.java b/core/java/com/android/internal/util/crdroid/DeviceConfigUtils.java
deleted file mode 100644
index 115c5199def8..000000000000
--- a/core/java/com/android/internal/util/crdroid/DeviceConfigUtils.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2023 The Pixel Experience Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.util.crdroid;
-
-import android.content.res.Resources;
-import android.provider.Settings;
-import android.util.Log;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import com.android.internal.util.ArrayUtils;
-
-public class DeviceConfigUtils {
-
-    private static final String TAG = DeviceConfigUtils.class.getSimpleName();
-
-    private static final boolean DEBUG = false;
-
-    private static String[] getDeviceConfigsOverride() {
-        String[] globalDeviceConfigs =
-            Resources.getSystem().getStringArray(com.android.internal.R.array.global_device_configs_override);
-        String[] deviceConfigs =
-            Resources.getSystem().getStringArray(com.android.internal.R.array.device_configs_override);
-        String[] allDeviceConfigs = Arrays.copyOf(globalDeviceConfigs, globalDeviceConfigs.length + deviceConfigs.length);
-        System.arraycopy(deviceConfigs, 0, allDeviceConfigs, globalDeviceConfigs.length, deviceConfigs.length);
-        return allDeviceConfigs;
-    }
-
-    public static boolean shouldDenyDeviceConfigControl(String namespace, String property) {
-        if (DEBUG) Log.d(TAG, "shouldAllowDeviceConfigControl, namespace=" + namespace + ", property=" + property);
-        for (String p : getDeviceConfigsOverride()) {
-            String[] kv = p.split("=");
-            String fullKey = kv[0];
-            String[] nsKey = fullKey.split("/");
-            if (nsKey[0] == namespace && nsKey[1] == property){
-                if (DEBUG) Log.d(TAG, "shouldAllowDeviceConfigControl, deny, namespace=" + namespace + ", property=" + property);
-                return true;
-            }
-        }
-        if (DEBUG) Log.d(TAG, "shouldAllowDeviceConfigControl, allow, namespace=" + namespace + ", property=" + property);
-        return false;
-    }
-
-    public static void setDefaultProperties(String filterNamespace, String filterProperty) {
-        if (DEBUG) Log.d(TAG, "setDefaultProperties");
-        for (String p : getDeviceConfigsOverride()) {
-            String[] kv = p.split("=");
-            String fullKey = kv[0];
-            String[] nsKey = fullKey.split("/");
-
-            String namespace = nsKey[0];
-            String key = nsKey[1];
-
-            if (filterNamespace != null && filterNamespace == namespace){
-                continue;
-            }
-
-            if (filterProperty != null && filterProperty == key){
-                continue;
-            }
-
-            String value = "";
-            if (kv.length > 1) {
-                value = kv[1];
-            }
-            Settings.Config.putString(namespace, key, value, false);
-        }
-    }
-}
diff --git a/core/java/com/android/internal/util/crdroid/PixelPropsUtils.java b/core/java/com/android/internal/util/crdroid/PixelPropsUtils.java
deleted file mode 100644
index 67f65e86bce4..000000000000
--- a/core/java/com/android/internal/util/crdroid/PixelPropsUtils.java
+++ /dev/null
@@ -1,431 +0,0 @@
-/*
- * Copyright (C) 2020 The Pixel Experience Project
- *               2021-2024 crDroid Android Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.util.crdroid;
-
-import android.app.Application;
-import android.os.Build;
-import android.os.SystemProperties;
-import android.util.Log;
-
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-public class PixelPropsUtils {
-
-    private static final String TAG = PixelPropsUtils.class.getSimpleName();
-    private static final String DEVICE = "ro.product.device";
-    private static final boolean DEBUG = false;
-
-    private static final String SPOOF_PIXEL_GAPPS = "persist.sys.pixelprops.gapps";
-    private static final String SPOOF_PIXEL_GMS = "persist.sys.pixelprops.gms";
-    private static final String SPOOF_PIXEL_GAMES = "persist.sys.pixelprops.games";
-    private static final String SPOOF_PIXEL_GPHOTOS = "persist.sys.pixelprops.gphotos";
-    private static final String SPOOF_PIXEL_NETFLIX = "persist.sys.pixelprops.netflix";
-
-    private static final Map<String, Object> propsToChangeGeneric;
-    private static final Map<String, Object> propsToChangePixel5a;
-    private static final Map<String, Object> propsToChangePixel8Pro;
-    private static final Map<String, Object> propsToChangePixelXL;
-    private static final Map<String, Object> propsToChangeROG6;
-    private static final Map<String, Object> propsToChangeXP5;
-    private static final Map<String, Object> propsToChangeOP8P;
-    private static final Map<String, Object> propsToChangeOP9P;
-    private static final Map<String, Object> propsToChangeMI11TP;
-    private static final Map<String, Object> propsToChangeMI13P;
-    private static final Map<String, Object> propsToChangeF5;
-    private static final Map<String, Object> propsToChangeBS4;
-    private static final Map<String, ArrayList<String>> propsToKeep;
-
-    // Packages to Spoof as Pixel 8 Pro
-    private static final String[] packagesToChangePixel8Pro = {
-            "com.android.chrome",
-            "com.android.vending",
-            "com.google.android.apps.customization.pixel",
-            "com.google.android.apps.emojiwallpaper",
-            "com.google.android.apps.privacy.wildlife",
-            "com.google.android.apps.wallpaper",
-            "com.google.android.apps.wallpaper.pixel",
-            "com.google.android.googlequicksearchbox",
-            "com.google.android.wallpaper.effects",
-            "com.google.pixel.livewallpaper",
-            "com.nhs.online.nhsonline",
-            "com.netflix.mediaclient"
-    };
-
-    // Packages to Spoof as Pixel 5a
-    private static final String[] packagesToChangePixel5a = {
-            "com.google.android.tts",
-            "com.breel.wallpapers20"
-    };
-
-    // Packages to Keep with original device
-    private static final String[] packagesToKeep = {
-            "com.google.android.apps.motionsense.bridge",
-            "com.google.android.apps.nexuslauncher",
-            "com.google.android.apps.pixelmigrate",
-            "com.google.android.apps.recorder",
-            "com.google.android.apps.restore",
-            "com.google.android.apps.subscriptions.red",
-            "com.google.android.apps.tachyon",
-            "com.google.android.apps.tycho",
-            "com.google.android.apps.wearables.maestro.companion",
-            "com.google.android.apps.youtube.kids",
-            "com.google.android.apps.youtube.music",
-            "com.google.android.as",
-            "com.google.android.backup",
-            "com.google.android.backuptransport",
-            "com.google.android.dialer",
-            "com.google.android.euicc",
-            "com.google.android.setupwizard",
-            "com.google.android.youtube",
-            "com.google.ar.core",
-            "com.google.intelligence.sense",
-            "com.google.oslo"
-    };
-
-    // Packages to Spoof as ROG Phone 6
-    private static final String[] packagesToChangeROG6 = {
-            "com.activision.callofduty.shooter",
-    	    "com.ea.gp.fifamobile",
-            "com.gameloft.android.ANMP.GloftA9HM",
-            "com.madfingergames.legends",
-            "com.pearlabyss.blackdesertm",
-            "com.pearlabyss.blackdesertm.gl"
-    };
-
-    // Packages to Spoof as Xperia 5
-    private static final String[] packagesToChangeXP5 = {
-            "com.garena.game.codm",
-            "com.tencent.tmgp.kr.codm",
-            "com.vng.codmvn"
-    };
-
-    // Packages to Spoof as OnePlus 8 Pro
-    private static final String[] packagesToChangeOP8P = {
-            "com.netease.lztgglobal",
-            "com.pubg.imobile",
-            "com.pubg.krmobile",
-            "com.rekoo.pubgm",
-            "com.riotgames.league.wildrift",
-            "com.riotgames.league.wildrifttw",
-            "com.riotgames.league.wildriftvn",
-            "com.riotgames.league.teamfighttactics",
-            "com.riotgames.league.teamfighttacticstw",
-            "com.riotgames.league.teamfighttacticsvn",
-            "com.tencent.ig",
-            "com.tencent.tmgp.pubgmhd",
-            "com.vng.pubgmobile"
-    };
-
-    // Packages to Spoof as OnePlus 9 Pro
-    private static final String[] packagesToChangeOP9P = {
-            "com.epicgames.fortnite",
-            "com.epicgames.portal",
-            "com.tencent.lolm"
-    };
-
-    // Packages to Spoof as Mi 11T Pro
-    private static final String[] packagesToChangeMI11TP = {
-            "com.ea.gp.apexlegendsmobilefps",
-            "com.levelinfinite.hotta.gp",
-            "com.supercell.clashofclans",
-            "com.vng.mlbbvn"
-    };
-
-    // Packages to Spoof as Xiaomi 13 Pro
-    private static final String[] packagesToChangeMI13P = {
-            "com.levelinfinite.sgameGlobal",
-            "com.tencent.tmgp.sgame"
-    };
-
-    // Packages to Spoof as POCO F5
-    private static final String[] packagesToChangeF5 = {
-            "com.dts.freefiremax",
-            "com.dts.freefireth",
-            "com.mobile.legends"
-    };
-
-    // Packages to Spoof as Black Shark 4
-    private static final String[] packagesToChangeBS4 = {
-            "com.proximabeta.mf.uamo"
-    };
-
-    private static volatile boolean sIsGms = false;
-    private static volatile boolean sIsFinsky = false;
-    private static volatile boolean sIsExcluded = false;
-
-    static {
-        propsToKeep = new HashMap<>();
-        propsToKeep.put("com.google.android.settings.intelligence", new ArrayList<>(Collections.singletonList("FINGERPRINT")));
-        propsToChangeGeneric = new HashMap<>();
-        propsToChangeGeneric.put("TYPE", "user");
-        propsToChangeGeneric.put("TAGS", "release-keys");
-        propsToChangePixel8Pro = new HashMap<>();
-        propsToChangePixel8Pro.put("BRAND", "google");
-        propsToChangePixel8Pro.put("MANUFACTURER", "Google");
-        propsToChangePixel8Pro.put("DEVICE", "husky");
-        propsToChangePixel8Pro.put("PRODUCT", "husky");
-        propsToChangePixel8Pro.put("HARDWARE", "husky");
-        propsToChangePixel8Pro.put("MODEL", "Pixel 8 Pro");
-        propsToChangePixel8Pro.put("ID", "AP1A.240405.002");
-        propsToChangePixel8Pro.put("FINGERPRINT", "google/husky/husky:14/AP1A.240405.002/11480754:user/release-keys");
-        propsToChangePixel5a = new HashMap<>();
-        propsToChangePixel5a.put("BRAND", "google");
-        propsToChangePixel5a.put("MANUFACTURER", "Google");
-        propsToChangePixel5a.put("DEVICE", "barbet");
-        propsToChangePixel5a.put("PRODUCT", "barbet");
-        propsToChangePixel5a.put("HARDWARE", "barbet");
-        propsToChangePixel5a.put("MODEL", "Pixel 5a");
-        propsToChangePixel5a.put("ID", "AP1A.240405.002");
-        propsToChangePixel5a.put("FINGERPRINT", "google/barbet/barbet:14/AP1A.240405.002/11480754:user/release-keys");
-        propsToChangePixelXL = new HashMap<>();
-        propsToChangePixelXL.put("BRAND", "google");
-        propsToChangePixelXL.put("MANUFACTURER", "Google");
-        propsToChangePixelXL.put("DEVICE", "marlin");
-        propsToChangePixelXL.put("PRODUCT", "marlin");
-        propsToChangePixelXL.put("HARDWARE", "marlin");
-        propsToChangePixelXL.put("MODEL", "Pixel XL");
-        propsToChangePixelXL.put("ID", "QP1A.191005.007.A3");
-        propsToChangePixelXL.put("FINGERPRINT", "google/marlin/marlin:10/QP1A.191005.007.A3/5972272:user/release-keys");
-        propsToChangeROG6 = new HashMap<>();
-        propsToChangeROG6.put("BRAND", "asus");
-        propsToChangeROG6.put("MANUFACTURER", "asus");
-        propsToChangeROG6.put("DEVICE", "AI2201");
-        propsToChangeROG6.put("MODEL", "ASUS_AI2201");
-        propsToChangeXP5 = new HashMap<>();
-        propsToChangeXP5.put("MODEL", "SO-52A");
-        propsToChangeXP5.put("MANUFACTURER", "Sony");
-        propsToChangeOP8P = new HashMap<>();
-        propsToChangeOP8P.put("MODEL", "IN2020");
-        propsToChangeOP8P.put("MANUFACTURER", "OnePlus");
-        propsToChangeOP9P = new HashMap<>();
-        propsToChangeOP9P.put("MODEL", "LE2123");
-        propsToChangeOP9P.put("MANUFACTURER", "OnePlus");
-        propsToChangeMI11TP = new HashMap<>();
-        propsToChangeMI11TP.put("MODEL", "2107113SI");
-        propsToChangeMI11TP.put("MANUFACTURER", "Xiaomi");
-        propsToChangeMI13P = new HashMap<>();
-        propsToChangeMI13P.put("BRAND", "Xiaomi");
-        propsToChangeMI13P.put("MANUFACTURER", "Xiaomi");
-        propsToChangeMI13P.put("MODEL", "2210132C");
-        propsToChangeF5 = new HashMap<>();
-        propsToChangeF5.put("MODEL", "23049PCD8G");
-        propsToChangeF5.put("MANUFACTURER", "Xiaomi");
-        propsToChangeBS4 = new HashMap<>();
-        propsToChangeBS4.put("MODEL", "2SM-X706B");
-        propsToChangeBS4.put("MANUFACTURER", "blackshark");
-    }
-
-    public static void setProps(String packageName) {
-        propsToChangeGeneric.forEach((k, v) -> setPropValue(k, v));
-
-        if (packageName == null || packageName.isEmpty()) {
-            return;
-        }
-        if (packageName.startsWith("com.google.")
-                || packageName.startsWith("com.samsung.")
-                || Arrays.asList(packagesToChangePixel8Pro).contains(packageName)
-                || Arrays.asList(packagesToChangePixel5a).contains(packageName)) {
-
-            if (!SystemProperties.getBoolean(SPOOF_PIXEL_GAPPS, true))
-                return;
-
-            if (Arrays.asList(packagesToKeep).contains(packageName) ||
-                    packageName.startsWith("com.google.android.GoogleCamera")) {
-                sIsExcluded = true;
-                return;
-            }
-
-            Map<String, Object> propsToChange = new HashMap<>();
-
-            if (packageName.equals("com.google.android.apps.photos")) {
-                if (SystemProperties.getBoolean(SPOOF_PIXEL_GPHOTOS, true)) {
-                    propsToChange.putAll(propsToChangePixelXL);
-                } else {
-                    propsToChange.putAll(propsToChangePixel5a);
-                }
-            } else if (packageName.equals("com.netflix.mediaclient") && 
-                        !SystemProperties.getBoolean(SPOOF_PIXEL_NETFLIX, false)) {
-                    if (DEBUG) Log.d(TAG, "Netflix spoofing disabled by system prop");
-                    return;
-            } else if (packageName.equals("com.android.vending") &&
-                    SystemProperties.getBoolean(SPOOF_PIXEL_GMS, true)) {
-                sIsFinsky = true;
-                return;
-            } else if (Arrays.asList(packagesToChangePixel8Pro).contains(packageName)) {
-                propsToChange.putAll(propsToChangePixel8Pro);
-            } else {
-                propsToChange.putAll(propsToChangePixel5a);
-            }
-
-            if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-            for (Map.Entry<String, Object> prop : propsToChange.entrySet()) {
-                String key = prop.getKey();
-                Object value = prop.getValue();
-                if (propsToKeep.containsKey(packageName) && propsToKeep.get(packageName).contains(key)) {
-                    if (DEBUG) Log.d(TAG, "Not defining " + key + " prop for: " + packageName);
-                    continue;
-                }
-                if (DEBUG) Log.d(TAG, "Defining " + key + " prop for: " + packageName);
-                setPropValue(key, value);
-            }
-            if (packageName.equals("com.google.android.gms") &&
-                    SystemProperties.getBoolean(SPOOF_PIXEL_GMS, true)) {
-                setPropValue("TIME", System.currentTimeMillis());
-                final String processName = Application.getProcessName();
-                if (processName.toLowerCase().contains("unstable")
-                    || processName.toLowerCase().contains("instrumentation")) {
-                    sIsGms = true;
-                    spoofBuildGms();
-                }
-                return;
-            }
-            // Set proper indexing fingerprint
-            if (packageName.equals("com.google.android.settings.intelligence")) {
-                setPropValue("FINGERPRINT", Build.VERSION.INCREMENTAL);
-            }
-        } else {
-
-            if (!SystemProperties.getBoolean(SPOOF_PIXEL_GAMES, false))
-                return;
-
-            if (Arrays.asList(packagesToChangeROG6).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeROG6.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeXP5).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeXP5.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeOP8P).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeOP8P.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeOP9P).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeOP9P.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeMI11TP).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeMI11TP.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeMI13P).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeMI13P.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeF5).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeF5.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeBS4).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeBS4.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            }
-        }
-    }
-
-    private static void setPropValue(String key, Object value) {
-        try {
-            if (DEBUG) Log.d(TAG, "Defining prop " + key + " to " + value.toString());
-            Field field = Build.class.getDeclaredField(key);
-            field.setAccessible(true);
-            field.set(null, value);
-            field.setAccessible(false);
-        } catch (NoSuchFieldException | IllegalAccessException e) {
-            Log.e(TAG, "Failed to set prop " + key, e);
-        }
-    }
-
-    private static void setVersionField(String key, Object value) {
-        try {
-            if (DEBUG) Log.d(TAG, "Defining prop " + key + " to " + value.toString());
-            Field field = Build.VERSION.class.getDeclaredField(key);
-            field.setAccessible(true);
-            field.set(null, value);
-            field.setAccessible(false);
-        } catch (NoSuchFieldException | IllegalAccessException e) {
-            Log.e(TAG, "Failed to set prop " + key, e);
-        }
-    }
-
-    private static void setVersionFieldString(String key, String value) {
-        try {
-            if (DEBUG) Log.d(TAG, "Defining prop " + key + " to " + value);
-            Field field = Build.VERSION.class.getDeclaredField(key);
-            field.setAccessible(true);
-            field.set(null, value);
-            field.setAccessible(false);
-        } catch (NoSuchFieldException | IllegalAccessException e) {
-            Log.e(TAG, "Failed to set prop " + key, e);
-        }
-    }
-
-    private static void spoofBuildGms() {
-        // Alter build parameters to avoid hardware attestation enforcement
-        setPropValue("BRAND", "motorola");
-        setPropValue("MANUFACTURER", "motorola");
-        setPropValue("DEVICE", "griffin");
-        setPropValue("ID", "MCC24.246-37");
-        setPropValue("FINGERPRINT", "motorola/griffin_retcn/griffin:6.0.1/MCC24.246-37/42:user/release-keys");
-        setPropValue("MODEL", "XT1650-05");
-        setPropValue("PRODUCT", "griffin_retcn");
-        setVersionFieldString("SECURITY_PATCH", "2016-07-01");
-    }
-
-    private static boolean isCallerSafetyNet() {
-        return sIsGms && Arrays.stream(Thread.currentThread().getStackTrace())
-                .anyMatch(elem -> elem.getClassName().contains("DroidGuard"));
-    }
-
-    public static void onEngineGetCertificateChain() {
-        // Check stack for SafetyNet or Play Integrity
-        if ((isCallerSafetyNet() || sIsFinsky) && !sIsExcluded) {
-            Log.i(TAG, "Blocked key attestation sIsGms=" + sIsGms + " sIsFinsky=" + sIsFinsky);
-            throw new UnsupportedOperationException();
-        }
-    }
-}
diff --git a/core/res/res/values/cr_config.xml b/core/res/res/values/cr_config.xml
index 000849d80214..0957d97769ed 100644
--- a/core/res/res/values/cr_config.xml
+++ b/core/res/res/values/cr_config.xml
@@ -126,13 +126,7 @@
     <!-- Whether to use Richtap vibration -->
     <bool name="config_usesRichtapVibration">false</bool>
 
-    <!-- Define device configs on boot -->
-    <string-array name="global_device_configs_override" translatable="false">
-    </string-array>
-    <string-array name="device_configs_override" translatable="false">
-    </string-array>
-
-  <!-- List of system apps that are allowed to be locked with app lock.
-        Use with extreme caution. -->
-  <string-array name="config_appLockAllowedSystemApps" translatable="false" />
+  	<!-- List of system apps that are allowed to be locked with app lock.
+  		 Use with extreme caution. -->
+  	<string-array name="config_appLockAllowedSystemApps" translatable="false" />
 </resources>
diff --git a/core/res/res/values/cr_symbols.xml b/core/res/res/values/cr_symbols.xml
index b549dc0c0329..1ed08c0c5383 100644
--- a/core/res/res/values/cr_symbols.xml
+++ b/core/res/res/values/cr_symbols.xml
@@ -96,10 +96,6 @@
     <!-- Whether to use Richtap vibration -->
     <java-symbol type="bool" name="config_usesRichtapVibration" />
 
-    <!-- Define device configs on boot -->
-    <java-symbol type="array" name="global_device_configs_override" />
-    <java-symbol type="array" name="device_configs_override" />
-
     <!-- App lock -->
     <java-symbol type="string" name="unlock_application" />
     <java-symbol type="array" name="config_appLockAllowedSystemApps" />
diff --git a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
index 4e594d3e57b2..9058cb510f6c 100644
--- a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
+++ b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
@@ -91,8 +91,6 @@ import java.util.NoSuchElementException;
 
 import javax.crypto.SecretKey;
 
-import com.android.internal.util.crdroid.PixelPropsUtils;
-
 /**
  * A java.security.KeyStore interface for the Android KeyStore. An instance of
  * it can be created via the {@link java.security.KeyStore#getInstance(String)
@@ -195,8 +193,6 @@ public class AndroidKeyStoreSpi extends KeyStoreSpi {
 
     @Override
     public Certificate[] engineGetCertificateChain(String alias) {
-        PixelPropsUtils.onEngineGetCertificateChain();
-
         KeyEntryResponse response = getKeyMetadata(alias);
 
         if (response == null || response.metadata.certificate == null) {
diff --git a/packages/SystemUI/res/drawable/face_not_verified.xml b/packages/SystemUI/res/drawable/face_not_verified.xml
deleted file mode 100644
index 03b0566d6f04..000000000000
--- a/packages/SystemUI/res/drawable/face_not_verified.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="24dp"
-    android:height="24dp"
-    android:viewportWidth="24"
-    android:viewportHeight="24"
-    android:tint="?attr/colorControlNormal">
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M15.5,9.5m-1.5,0a1.5,1.5 0,1 1,3 0a1.5,1.5 0,1 1,-3 0"/>
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M8.5,9.5m-1.5,0a1.5,1.5 0,1 1,3 0a1.5,1.5 0,1 1,-3 0"/>
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M12,14c-2.33,0 -4.32,1.45 -5.12,3.5h1.67c0.69,-1.19 1.97,-2 3.45,-2s2.75,0.81 3.45,2h1.67c-0.8,-2.05 -2.79,-3.5 -5.12,-3.5zM11.99,2C6.47,2 2,6.48 2,12s4.47,10 9.99,10C17.52,22 22,17.52 22,12S17.52,2 11.99,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8z"/>
-</vector>
diff --git a/packages/SystemUI/res/drawable/face_scanning.xml b/packages/SystemUI/res/drawable/face_scanning.xml
deleted file mode 100644
index 27de6c80ef20..000000000000
--- a/packages/SystemUI/res/drawable/face_scanning.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="24dp"
-    android:height="24dp"
-    android:viewportWidth="24"
-    android:viewportHeight="24"
-    android:tint="?attr/colorControlNormal">
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M10.25,13c0,0.69 -0.56,1.25 -1.25,1.25S7.75,13.69 7.75,13s0.56,-1.25 1.25,-1.25 1.25,0.56 1.25,1.25zM15,11.75c-0.69,0 -1.25,0.56 -1.25,1.25s0.56,1.25 1.25,1.25 1.25,-0.56 1.25,-1.25 -0.56,-1.25 -1.25,-1.25zM22,12c0,5.52 -4.48,10 -10,10S2,17.52 2,12 6.48,2 12,2s10,4.48 10,10zM10.66,4.12C12.06,6.44 14.6,8 17.5,8c0.46,0 0.91,-0.05 1.34,-0.12C17.44,5.56 14.9,4 12,4c-0.46,0 -0.91,0.05 -1.34,0.12zM4.42,9.47c1.71,-0.97 3.03,-2.55 3.66,-4.44C6.37,6 5.05,7.58 4.42,9.47zM20,12c0,-0.78 -0.12,-1.53 -0.33,-2.24 -0.7,0.15 -1.42,0.24 -2.17,0.24 -3.13,0 -5.92,-1.44 -7.76,-3.69C8.69,8.87 6.6,10.88 4,11.86c0.01,0.04 0,0.09 0,0.14 0,4.41 3.59,8 8,8s8,-3.59 8,-8z"/>
-</vector>
diff --git a/packages/SystemUI/res/drawable/face_success.xml b/packages/SystemUI/res/drawable/face_success.xml
deleted file mode 100644
index d63dacb1512e..000000000000
--- a/packages/SystemUI/res/drawable/face_success.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="24dp"
-    android:height="24dp"
-    android:viewportWidth="24"
-    android:viewportHeight="24"
-    android:tint="?attr/colorControlNormal">
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M15.5,9.5m-1.5,0a1.5,1.5 0,1 1,3 0a1.5,1.5 0,1 1,-3 0"/>
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M8.5,9.5m-1.5,0a1.5,1.5 0,1 1,3 0a1.5,1.5 0,1 1,-3 0"/>
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M12,16c-1.48,0 -2.75,-0.81 -3.45,-2L6.88,14c0.8,2.05 2.79,3.5 5.12,3.5s4.32,-1.45 5.12,-3.5h-1.67c-0.69,1.19 -1.97,2 -3.45,2zM11.99,2C6.47,2 2,6.48 2,12s4.47,10 9.99,10C17.52,22 22,17.52 22,12S17.52,2 11.99,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8z"/>
-</vector>
diff --git a/packages/SystemUI/res/layout/keyguard_bottom_area.xml b/packages/SystemUI/res/layout/keyguard_bottom_area.xml
index 6e6a2881ffbe..6d7ce0623817 100644
--- a/packages/SystemUI/res/layout/keyguard_bottom_area.xml
+++ b/packages/SystemUI/res/layout/keyguard_bottom_area.xml
@@ -30,17 +30,6 @@
         android:layout_gravity="bottom|center_horizontal"
         android:orientation="vertical">
 
-        <com.android.systemui.statusbar.phone.FaceUnlockImageView
-            android:id="@+id/face_unlock_icon"
-            android:layout_height="@dimen/keyguard_affordance_fixed_height"
-            android:layout_width="@dimen/keyguard_affordance_fixed_width"
-            android:layout_marginBottom="@dimen/keyguard_affordance_vertical_offset"
-            android:padding="@dimen/keyguard_affordance_fixed_padding"
-            android:layout_gravity="center"
-            android:scaleType="fitCenter"
-            android:tint="?android:attr/textColorPrimary"
-            android:visibility="gone" />
-
         <com.android.systemui.statusbar.phone.KeyguardIndicationTextView
             android:id="@id/keyguard_indication_text"
             android:layout_width="match_parent"
diff --git a/packages/SystemUI/res/values/cr_strings.xml b/packages/SystemUI/res/values/cr_strings.xml
index dcddf4dbe90b..810a5849ca49 100644
--- a/packages/SystemUI/res/values/cr_strings.xml
+++ b/packages/SystemUI/res/values/cr_strings.xml
@@ -171,7 +171,4 @@
     <!-- Island notification -->
     <string name="now_playing_on">Now Playing on %1$s</string>
     <string name="by_artist">%1$s by %2$s</string>
-
-    <!-- Text while recognizing face -->
-    <string name="face_unlock_recognizing">Recognizing face...</string>
 </resources>
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/data/repository/PromptRepository.kt b/packages/SystemUI/src/com/android/systemui/biometrics/data/repository/PromptRepository.kt
index cf2f899b80f0..b35fbbc7bb32 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/data/repository/PromptRepository.kt
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/data/repository/PromptRepository.kt
@@ -110,9 +110,17 @@ constructor(
 
     private val _faceSettings =
         _userId.map { id -> faceSettings.forUser(id) }.distinctUntilChanged()
+    private val _faceSettingAlwaysRequireConfirmation =
+        _faceSettings.flatMapLatest { it.alwaysRequireConfirmationInApps }.distinctUntilChanged()
 
+    private val _isConfirmationRequired = _promptInfo.map { it?.isConfirmationRequested ?: false }
     override val isConfirmationRequired =
-        _faceSettings.flatMapLatest { it.alwaysRequireConfirmationInApps }.distinctUntilChanged()
+        combine(_isConfirmationRequired, _faceSettingAlwaysRequireConfirmation) {
+                appRequiresConfirmation,
+                forceRequireConfirmation ->
+                forceRequireConfirmation || appRequiresConfirmation
+            }
+            .distinctUntilChanged()
 
     override fun setPrompt(
         promptInfo: PromptInfo,
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/ui/viewmodel/PromptViewModel.kt b/packages/SystemUI/src/com/android/systemui/biometrics/ui/viewmodel/PromptViewModel.kt
index ea50d01127c2..6d0a58e202bd 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/ui/viewmodel/PromptViewModel.kt
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/ui/viewmodel/PromptViewModel.kt
@@ -155,7 +155,10 @@ constructor(
      * If the API caller or the user's personal preferences require explicit confirmation after
      * successful authentication. Confirmation always required when in explicit flow.
      */
-    val isConfirmationRequired: Flow<Boolean> = promptSelectorInteractor.isConfirmationRequired
+    val isConfirmationRequired: Flow<Boolean> =
+        combine(_isOverlayTouched, size) { isOverlayTouched, size ->
+            !isOverlayTouched && size.isNotSmall
+        }
 
     /**
      * When fingerprint and face modalities are enrolled, indicates whether only face auth has
@@ -473,9 +476,11 @@ constructor(
     }
 
     private suspend fun needsExplicitConfirmation(modality: BiometricModality): Boolean {
+        val confirmationRequired = isConfirmationRequired.first()
+
         // Only worry about confirmationRequired if face was used to unlock
         if (modality == BiometricModality.Face) {
-            return isConfirmationRequired.first()
+            return confirmationRequired
         }
         // fingerprint only never requires confirmation
         return false
diff --git a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
index cc4ce05a4282..fedbdec113f8 100644
--- a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
+++ b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
@@ -95,10 +95,6 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
                 if (code in OPS_LOCATION && !locationAvailable) {
                     return
                 }
-                // Hide incoming chip from sense caller package
-                if (packageName == "co.aospa.sense") {
-                    return
-                }
                 if (userTracker.userProfiles.any { it.id == UserHandle.getUserId(uid) } ||
                         code in USER_INDEPENDENT_OPS) {
                     logger.logUpdatedItemFromAppOps(code, uid, packageName, active)
@@ -223,10 +219,6 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
             AppOpsManager.OP_RECORD_AUDIO -> PrivacyType.TYPE_MICROPHONE
             else -> return null
         }
-        // Hide incoming chip from sense caller package
-        if (appOpItem.packageName == "co.aospa.sense") {
-            return null
-        }
         val app = PrivacyApplication(appOpItem.packageName, appOpItem.uid)
         return PrivacyItem(type, app, appOpItem.timeStartedElapsed, appOpItem.isDisabled)
     }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
index b18cfc4cefc8..a02dff72b16d 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
@@ -108,7 +108,6 @@ import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.res.R;
 import com.android.systemui.settings.UserTracker;
-import com.android.systemui.statusbar.phone.FaceUnlockImageView;
 import com.android.systemui.statusbar.phone.KeyguardBypassController;
 import com.android.systemui.statusbar.phone.KeyguardIndicationTextView;
 import com.android.systemui.statusbar.phone.StatusBarKeyguardViewManager;
@@ -146,8 +145,6 @@ public class KeyguardIndicationController {
 
     private static final int MSG_SHOW_ACTION_TO_UNLOCK = 1;
     private static final int MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON = 2;
-    private static final int MSG_SHOW_RECOGNIZING_FACE = 3;
-    private static final int MSG_HIDE_RECOGNIZING_FACE = 4;
     private static final long TRANSIENT_BIOMETRIC_ERROR_TIMEOUT = 1300;
     public static final long DEFAULT_HIDE_DELAY_MS =
             3500 + KeyguardIndicationTextView.Y_IN_DURATION;
@@ -162,7 +159,6 @@ public class KeyguardIndicationController {
     private final UserTracker mUserTracker;
     private final BouncerMessageInteractor mBouncerMessageInteractor;
     private ViewGroup mIndicationArea;
-    private FaceUnlockImageView mFaceIconView;
     private KeyguardIndicationTextView mTopIndicationView;
     private KeyguardIndicationTextView mLockScreenIndicationView;
     private final IBatteryStats mBatteryInfo;
@@ -217,8 +213,6 @@ public class KeyguardIndicationController {
     private final FaceHelpMessageDeferral mFaceAcquiredMessageDeferral;
     private boolean mInited;
 
-    private boolean mFaceDetectionRunning;
-
     private int mCurrentDivider;
 
     private boolean mHasDashCharger;
@@ -256,15 +250,6 @@ public class KeyguardIndicationController {
                 mBiometricErrorMessageToShowOnScreenOn = null;
             }
         }
-
-        @Override
-        public void onScreenTurnedOff() {
-            if (mFaceDetectionRunning) {
-                mFaceDetectionRunning = false;
-                mBiometricErrorMessageToShowOnScreenOn = null;
-                hideFaceUnlockRecognizingMessage();
-            }
-        }
     };
     private boolean mFaceLockedOutThisAuthSession;
 
@@ -352,11 +337,6 @@ public class KeyguardIndicationController {
                     showActionToUnlock();
                 } else if (msg.what == MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON) {
                     mBiometricErrorMessageToShowOnScreenOn = null;
-                } else if (msg.what == MSG_SHOW_RECOGNIZING_FACE) {
-                    mBiometricErrorMessageToShowOnScreenOn = null;
-                    showFaceUnlockRecognizingMessage();
-                } else if (msg.what == MSG_HIDE_RECOGNIZING_FACE) {
-                    hideFaceUnlockRecognizingMessage();
                 }
             }
         };
@@ -410,7 +390,6 @@ public class KeyguardIndicationController {
 
     public void setIndicationArea(ViewGroup indicationArea) {
         mIndicationArea = indicationArea;
-        mFaceIconView = indicationArea.findViewById(R.id.face_unlock_icon);
         mTopIndicationView = indicationArea.findViewById(R.id.keyguard_indication_text);
         mLockScreenIndicationView = indicationArea.findViewById(
             R.id.keyguard_indication_text_bottom);
@@ -905,12 +884,6 @@ public class KeyguardIndicationController {
                 && TextUtils.equals(biometricMessageFollowUp, mBiometricMessageFollowUp)) {
             return;
         }
-        
-        if (TextUtils.equals(biometricMessage, mContext.getString(R.string.keyguard_face_successful_unlock))) {
-            mFaceIconView.setState(FaceUnlockImageView.State.SUCCESS);
-        } else if (TextUtils.equals(biometricMessage, mContext.getString(R.string.keyguard_face_failed))) {
-            mFaceIconView.setState(FaceUnlockImageView.State.NOT_VERIFIED);
-        }
 
         mBiometricMessage = biometricMessage;
         mBiometricMessageFollowUp = biometricMessageFollowUp;
@@ -935,25 +908,6 @@ public class KeyguardIndicationController {
         }
     }
 
-    private void showFaceUnlockRecognizingMessage() {
-        mFaceIconView.setVisibility(View.VISIBLE);
-        mFaceIconView.setState(FaceUnlockImageView.State.SCANNING);
-        showBiometricMessage(mContext.getResources().getString(
-                                    R.string.face_unlock_recognizing));
-    }
-
-    private void hideFaceUnlockRecognizingMessage() {
-        if (mFaceIconView != null) {
-            mFaceIconView.setVisibility(View.GONE);
-        }
-        String faceUnlockMessage = mContext.getResources().getString(
-            R.string.face_unlock_recognizing);
-        if (mBiometricMessage != null && mBiometricMessage == faceUnlockMessage) {
-            mBiometricMessage = null;
-            hideBiometricMessage();
-        }
-    }
-
     /**
      * Hides transient indication.
      */
@@ -1496,17 +1450,11 @@ public class KeyguardIndicationController {
         @Override
         public void onBiometricRunningStateChanged(boolean running,
                 BiometricSourceType biometricSourceType) {
-            if (biometricSourceType == BiometricSourceType.FACE) {
-                mFaceDetectionRunning = running;
-                if (running) {
-                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
-                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
-                    mHandler.sendEmptyMessageDelayed(MSG_SHOW_RECOGNIZING_FACE, 100);
-                } else {
-                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
-                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
-                    mHandler.sendEmptyMessageDelayed(MSG_HIDE_RECOGNIZING_FACE, 100);
-                }
+            if (running && biometricSourceType == FACE) {
+                // Let's hide any previous messages when authentication starts, otherwise
+                // multiple auth attempts would overlap.
+                hideBiometricMessage();
+                mBiometricErrorMessageToShowOnScreenOn = null;
             }
         }
 
@@ -1661,7 +1609,6 @@ public class KeyguardIndicationController {
 
             if (mDozing) {
                 hideBiometricMessage();
-                hideFaceUnlockRecognizingMessage();
             }
             updateDeviceEntryIndication(false);
         }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
index 1d4069ae3b3c..97fc35a062f4 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
@@ -618,7 +618,7 @@ public class BiometricUnlockController extends KeyguardUpdateMonitorCallback imp
         final boolean unlockingAllowed =
                 mUpdateMonitor.isUnlockingWithBiometricAllowed(isStrongBiometric);
         final boolean deviceDreaming = mUpdateMonitor.isDreaming();
-        final boolean bypass = mKeyguardBypassController.getBypassEnabledBiometric()
+        final boolean bypass = mKeyguardBypassController.getBypassEnabled()
                 || mAuthController.isUdfpsFingerDown();
 
         logCalculateModeForPassiveAuth(unlockingAllowed, deviceInteractive, isKeyguardShowing,
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/FaceUnlockImageView.kt b/packages/SystemUI/src/com/android/systemui/statusbar/phone/FaceUnlockImageView.kt
deleted file mode 100644
index 5b6c7beff8dc..000000000000
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/FaceUnlockImageView.kt
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2023 the risingOS Android Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.systemui.statusbar.phone
-
-import android.animation.ObjectAnimator
-import android.animation.AnimatorSet
-import android.animation.PropertyValuesHolder
-import android.content.Context
-import android.util.AttributeSet
-import android.widget.ImageView
-import android.view.animation.LinearInterpolator
-import android.view.animation.AccelerateDecelerateInterpolator
-import android.view.animation.DecelerateInterpolator
-
-import com.android.systemui.R
-
-class FaceUnlockImageView @JvmOverloads constructor(
-    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
-) : ImageView(context, attrs, defStyleAttr) {
-
-    enum class State {
-        SCANNING, NOT_VERIFIED, SUCCESS
-    }
-
-    private var currentState: State = State.SCANNING
-    private val scanningAnimation: ObjectAnimator = createScanningAnimation()
-    private val successShakeAnimation: AnimatorSet = createShakeAnimation(5f)
-    private val failureShakeAnimation: AnimatorSet = createShakeAnimation(10f)
-
-    init {
-        updateDrawable(animate = false)
-    }
-
-    fun setState(state: State) {
-        if (currentState != state) {
-            currentState = state
-            updateDrawable(animate = true)
-            handleAnimationForState(state)
-        }
-    }
-
-    private fun updateDrawable(animate: Boolean) {
-        setImageResource(when (currentState) {
-            State.SCANNING -> R.drawable.face_scanning
-            State.NOT_VERIFIED -> R.drawable.face_not_verified
-            State.SUCCESS -> R.drawable.face_success
-        })
-    }
-
-    private fun createScanningAnimation(): ObjectAnimator {
-        val scaleX = PropertyValuesHolder.ofFloat("scaleX", 1f, 1.2f, 1f)
-        val scaleY = PropertyValuesHolder.ofFloat("scaleY", 1f, 1.2f, 1f)
-        val scanningAnimator = ObjectAnimator.ofPropertyValuesHolder(this, scaleX, scaleY)
-        scanningAnimator.duration = 1000
-        scanningAnimator.repeatCount = ObjectAnimator.INFINITE
-        scanningAnimator.interpolator = LinearInterpolator()
-        return scanningAnimator
-    }
-
-    private fun createShakeAnimation(amplitude: Float): AnimatorSet {
-        val animatorSet = AnimatorSet()
-        val translationX = PropertyValuesHolder.ofFloat("translationX", 0f, amplitude, -amplitude, amplitude, -amplitude, 0f)
-        val shakeAnimator = ObjectAnimator.ofPropertyValuesHolder(this, translationX)
-        shakeAnimator.duration = 500
-        shakeAnimator.interpolator = AccelerateDecelerateInterpolator()
-        animatorSet.play(shakeAnimator)
-        return animatorSet
-    }
-
-    private fun handleAnimationForState(state: State) {
-        when (state) {
-            State.SCANNING -> {
-                failureShakeAnimation.cancel()
-                successShakeAnimation.cancel()
-                scanningAnimation.start()
-            }
-            State.NOT_VERIFIED -> {
-                scanningAnimation.cancel()
-                successShakeAnimation.cancel()
-                failureShakeAnimation.start()
-            }
-            State.SUCCESS -> {
-                scanningAnimation.cancel()
-                failureShakeAnimation.cancel()
-                successShakeAnimation.start()
-            }
-        }
-    }
-}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
index 866bc590d33f..a3d316b611a7 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
@@ -107,8 +107,6 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             notifyListeners()
         }
 
-    var bypassEnabledBiometric: Boolean = false
-
     var bouncerShowing: Boolean = false
     var altBouncerShowing: Boolean = false
     var launchingAffordance: Boolean = false
@@ -165,7 +163,7 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
                 com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
 
         tunerService.addTunable({ key, _ ->
-            bypassEnabledBiometric = tunerService.getValue(key, dismissByDefault) != 0
+            bypassEnabled = tunerService.getValue(key, dismissByDefault) != 0
         }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
 
         lockscreenUserManager.addUserChangedListener(
@@ -202,8 +200,8 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
         biometricSourceType: BiometricSourceType,
         isStrongBiometric: Boolean
     ): Boolean {
-        if (bypassEnabledBiometric) {
-            val can = biometricSourceType != BiometricSourceType.FACE || canBypass()
+        if (biometricSourceType == BiometricSourceType.FACE && bypassEnabled) {
+            val can = canBypass()
             if (!can && (isPulseExpanding || qsExpanded)) {
                 pendingUnlock = PendingUnlock(biometricSourceType, isStrongBiometric)
             }
@@ -227,7 +225,7 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
      * If keyguard can be dismissed because of bypass.
      */
     fun canBypass(): Boolean {
-        if (bypassEnabledBiometric) {
+        if (bypassEnabled) {
             return when {
                 bouncerShowing -> true
                 altBouncerShowing -> true
@@ -260,7 +258,6 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             pw.println("  mPendingUnlock: $pendingUnlock")
         }
         pw.println("  bypassEnabled: $bypassEnabled")
-        pw.println("  bypassEnabledBiometric: $bypassEnabledBiometric")
         pw.println("  canBypass: ${canBypass()}")
         pw.println("  bouncerShowing: $bouncerShowing")
         pw.println("  altBouncerShowing: $altBouncerShowing")
diff --git a/services/applock/java/com/android/server/app/BiometricUnlocker.kt b/services/applock/java/com/android/server/app/BiometricUnlocker.kt
index 484fd9352d03..0e3f774975a0 100644
--- a/services/applock/java/com/android/server/app/BiometricUnlocker.kt
+++ b/services/applock/java/com/android/server/app/BiometricUnlocker.kt
@@ -46,7 +46,7 @@ internal class BiometricUnlocker(private val context: Context) {
      */
     fun canUnlock(): Boolean =
         biometricManager.canAuthenticate(
-            Authenticators.BIOMETRIC_WEAK or
+            Authenticators.BIOMETRIC_STRONG or
                 Authenticators.DEVICE_CREDENTIAL
         ) == BiometricManager.BIOMETRIC_SUCCESS
 
@@ -91,13 +91,12 @@ internal class BiometricUnlocker(private val context: Context) {
     ) {
         var authenticators = Authenticators.DEVICE_CREDENTIAL
         if (biometricsAllowed) {
-            authenticators = authenticators or Authenticators.BIOMETRIC_WEAK
+            authenticators = authenticators or Authenticators.BIOMETRIC_STRONG
         }
         val prompt = BiometricPrompt.Builder(context)
             .setTitle(title)
             .setAllowedAuthenticators(authenticators)
             .setAllowBackgroundAuthentication(true)
-            .setConfirmationRequired(false)
             .build()
         prompt.authenticateUser(
             CancellationSignal(),
diff --git a/services/core/Android.bp b/services/core/Android.bp
index d9e7383b6441..1664073a228a 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -206,7 +206,6 @@ java_library_static {
         "com.android.server.utils_aconfig-java",
         "service-jobscheduler-deviceidle.flags-aconfig-java",
         "vendor.aac.hardware.richtap.vibrator",
-        "vendor.aospa.biometrics.face",
     ],
     javac_shard_size: 50,
     javacflags: [
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
index 79ad70987904..578d9dc2aede 100644
--- a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
+++ b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
@@ -25,7 +25,6 @@ import android.annotation.Nullable;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.hardware.biometrics.BiometricsProtoEnums;
-import android.hardware.biometrics.SensorProperties;
 import android.hardware.biometrics.IBiometricSensorReceiver;
 import android.hardware.biometrics.IBiometricService;
 import android.hardware.biometrics.IBiometricServiceLockoutResetCallback;
@@ -37,7 +36,6 @@ import android.hardware.biometrics.face.IFace;
 import android.hardware.biometrics.face.SensorProps;
 import android.hardware.face.Face;
 import android.hardware.face.FaceAuthenticateOptions;
-import android.hardware.face.FaceSensorProperties;
 import android.hardware.face.FaceSensorPropertiesInternal;
 import android.hardware.face.FaceServiceReceiver;
 import android.hardware.face.IFaceAuthenticatorsRegisteredCallback;
@@ -69,8 +67,6 @@ import com.android.server.biometrics.sensors.LockoutResetDispatcher;
 import com.android.server.biometrics.sensors.LockoutTracker;
 import com.android.server.biometrics.sensors.face.aidl.FaceProvider;
 import com.android.server.biometrics.sensors.face.hidl.Face10;
-import com.android.server.biometrics.sensors.face.sense.SenseProvider;
-import com.android.server.biometrics.sensors.face.sense.SenseUtils;
 
 import com.google.android.collect.Lists;
 
@@ -686,24 +682,6 @@ public class FaceService extends SystemService {
             return providers;
         }
 
-        private List<ServiceProvider> getSenseProviders() {
-            final List<ServiceProvider> providers = new ArrayList<>();
-            if (SenseUtils.canUseProvider()) {
-                FaceSensorPropertiesInternal props = new FaceSensorPropertiesInternal(
-                        SenseProvider.DEVICE_ID,
-                        SensorProperties.STRENGTH_WEAK,
-                        1, /** maxEnrollmentsPerUser **/
-                        new ArrayList(),
-                        FaceSensorProperties.TYPE_RGB,
-                        false, /** supportsFaceDetection **/
-                        false, /** supportsSelfIllumination **/
-                        false); /** resetLockoutRequiresChallenge **/
-                SenseProvider provider = new SenseProvider(getContext(), mBiometricStateCallback, props, mLockoutResetDispatcher);
-                providers.add(provider);
-            }
-            return providers;
-        }
-
         @android.annotation.EnforcePermission(android.Manifest.permission.USE_BIOMETRIC_INTERNAL)
         public void registerAuthenticators(
                 @NonNull List<FaceSensorPropertiesInternal> hidlSensors) {
@@ -720,11 +698,8 @@ public class FaceService extends SystemService {
                         filteredInstances = filterAvailableHalInstances(hidlSensors, aidlSensors);
 
                 final List<ServiceProvider> providers = new ArrayList<>();
-                /*
                 providers.addAll(getHidlProviders(filteredInstances.first));
                 providers.addAll(getAidlProviders(filteredInstances.second));
-                */
-                providers.addAll(getSenseProviders());
                 return providers;
             });
         }
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/BiometricTestSessionImpl.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/BiometricTestSessionImpl.java
deleted file mode 100644
index cdb4b46d0117..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/BiometricTestSessionImpl.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.hardware.biometrics.ITestSession;
-import android.hardware.biometrics.ITestSessionCallback;
-import android.hardware.face.Face;
-import android.hardware.face.FaceAuthenticationFrame;
-import android.hardware.face.FaceEnrollFrame;
-import android.hardware.face.IFaceServiceReceiver;
-import android.os.Binder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.BiometricStateCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.face.FaceUtils;
-
-import java.util.List;
-import java.util.Random;
-
-/**
- * A test session implementation for {@link SenseProvider}. See
- * {@link android.hardware.biometrics.BiometricTestSession}.
- */
-public class BiometricTestSessionImpl extends ITestSession.Stub {
-
-    private static final String TAG = "face/sense/BiometricTestSessionImpl";
-
-    @NonNull private final Context mContext;
-    private final int mSensorId;
-    @NonNull private final ITestSessionCallback mCallback;
-    @NonNull private final Random mRandom;
-
-    @NonNull private final SenseProvider.HalResultController mHalResultController;
-    @NonNull private final SenseProvider mSenseProvider;
-
-    /**
-     * Internal receiver currently only used for enroll. Results do not need to be forwarded to the
-     * test, since enrollment is a platform-only API. The authentication path is tested through
-     * the public BiometricPrompt APIs and does not use this receiver.
-     */
-    private final IFaceServiceReceiver mReceiver = new IFaceServiceReceiver.Stub() {
-        @Override
-        public void onEnrollResult(Face face, int remaining) {
-
-        }
-
-        @Override
-        public void onAcquired(int acquireInfo, int vendorCode) {
-
-        }
-
-        @Override
-        public void onAuthenticationSucceeded(Face face, int userId, boolean isStrongBiometric) {
-
-        }
-
-        @Override
-        public void onFaceDetected(int sensorId, int userId, boolean isStrongBiometric) {
-
-        }
-
-        @Override
-        public void onAuthenticationFailed() {
-
-        }
-
-        @Override
-        public void onError(int error, int vendorCode) {
-
-        }
-
-        @Override
-        public void onRemoved(Face face, int remaining) {
-
-        }
-
-        @Override
-        public void onFeatureSet(boolean success, int feature) {
-
-        }
-
-        @Override
-        public void onFeatureGet(boolean success, int[] features, boolean[] featureState) {
-
-        }
-
-        @Override
-        public void onChallengeGenerated(int sensorId, int userId, long challenge) {
-
-        }
-
-        @Override
-        public void onAuthenticationFrame(FaceAuthenticationFrame frame) {
-
-        }
-
-        @Override
-        public void onEnrollmentFrame(FaceEnrollFrame frame) {
-
-        }
-    };
-
-    BiometricTestSessionImpl(@NonNull Context context, int sensorId,
-            @NonNull ITestSessionCallback callback, @NonNull SenseProvider provider,
-            @NonNull SenseProvider.HalResultController halResultController) {
-        mContext = context;
-        mSensorId = sensorId;
-        mCallback = callback;
-        mSenseProvider = provider;
-        mHalResultController = halResultController;
-        mRandom = new Random();
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void setTestHalEnabled(boolean enabled) {
-        super.setTestHalEnabled_enforcePermission();
-
-        mSenseProvider.setTestHalEnabled(enabled);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void startEnroll(int userId) {
-        super.startEnroll_enforcePermission();
-
-        mSenseProvider.scheduleEnroll(mSensorId, new Binder(), new byte[69], userId, mReceiver,
-                mContext.getOpPackageName(), new int[0] /* disabledFeatures */,
-                null /* previewSurface */, false /* debugConsent */);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void finishEnroll(int userId) {
-        super.finishEnroll_enforcePermission();
-
-        mHalResultController.onEnrollResult(1, userId, 0);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void acceptAuthentication(int userId) {
-        super.acceptAuthentication_enforcePermission();
-
-        // Fake authentication with any of the existing faces
-        List<Face> faces = FaceUtils.getInstance(mSensorId)
-                .getBiometricsForUser(mContext, userId);
-        if (faces.isEmpty()) {
-            Slog.w(TAG, "No faces, returning");
-            return;
-        }
-        final int fid = faces.get(0).getBiometricId();
-        byte[] hat = {0};
-        mHalResultController.onAuthenticated(0 /* deviceId */, userId, hat);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void rejectAuthentication(int userId) {
-        super.rejectAuthentication_enforcePermission();
-
-        mHalResultController.onAuthenticated(0 /* deviceId */, userId, null);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void notifyAcquired(int userId, int acquireInfo) {
-        super.notifyAcquired_enforcePermission();
-
-        mHalResultController.onAcquired(userId, 0 /* deviceId */, 0 /* vendorCode */);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void notifyError(int userId, int errorCode) {
-        super.notifyError_enforcePermission();
-
-        mHalResultController.onError(0 /* deviceId */, 0 /* vendorCode */);
-    }
-
-    @android.annotation.EnforcePermission(android.Manifest.permission.TEST_BIOMETRIC)
-    @Override
-    public void cleanupInternalState(int userId) {
-        super.cleanupInternalState_enforcePermission();
-
-        mSenseProvider.scheduleInternalCleanup(mSensorId, userId, new ClientMonitorCallback() {
-            @Override
-            public void onClientStarted(@NonNull BaseClientMonitor clientMonitor) {
-                try {
-                    mCallback.onCleanupStarted(clientMonitor.getTargetUserId());
-                } catch (RemoteException e) {
-                    Slog.e(TAG, "Remote exception", e);
-                }
-            }
-
-            @Override
-            public void onClientFinished(@NonNull BaseClientMonitor clientMonitor,
-                    boolean success) {
-                try {
-                    mCallback.onCleanupFinished(clientMonitor.getTargetUserId());
-                } catch (RemoteException e) {
-                    Slog.e(TAG, "Remote exception", e);
-                }
-            }
-        });
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceAuthenticationClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceAuthenticationClient.java
deleted file mode 100644
index 118970dcd14f..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceAuthenticationClient.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.content.res.Resources;
-import android.hardware.SensorPrivacyManager;
-import android.hardware.biometrics.BiometricAuthenticator;
-import android.hardware.biometrics.BiometricConstants;
-import android.hardware.biometrics.BiometricFaceConstants;
-import android.hardware.biometrics.BiometricManager.Authenticators;
-import android.hardware.biometrics.face.V1_0.IBiometricsFace;
-import android.hardware.face.FaceAuthenticateOptions;
-import android.hardware.face.FaceManager;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.R;
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.AuthenticationClient;
-import com.android.server.biometrics.sensors.BiometricNotificationUtils;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.ClientMonitorCompositeCallback;
-import com.android.server.biometrics.sensors.LockoutTracker;
-import com.android.server.biometrics.sensors.PerformanceTracker;
-import com.android.server.biometrics.sensors.face.UsageStats;
-
-import java.util.ArrayList;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-/**
- * Face-specific authentication client supporting the {@link android.hardware.biometrics.face.V1_0}
- * HIDL interface.
- */
-class FaceAuthenticationClient
-        extends AuthenticationClient<ISenseService, FaceAuthenticateOptions> {
-
-    private static final String TAG = "FaceAuthenticationClient";
-
-    private final UsageStats mUsageStats;
-
-    private final int[] mBiometricPromptIgnoreList;
-    private final int[] mBiometricPromptIgnoreListVendor;
-    private final int[] mKeyguardIgnoreList;
-    private final int[] mKeyguardIgnoreListVendor;
-
-    private int mLastAcquire;
-
-    FaceAuthenticationClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon,
-            @NonNull IBinder token, long requestId,
-            @NonNull ClientMonitorCallbackConverter listener, long operationId,
-            boolean restricted, @NonNull FaceAuthenticateOptions options, int cookie,
-            boolean requireConfirmation,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext,
-            boolean isStrongBiometric, @NonNull LockoutTracker lockoutTracker,
-            @NonNull UsageStats usageStats, boolean allowBackgroundAuthentication,
-            @Authenticators.Types int sensorStrength) {
-        super(context, lazyDaemon, token, listener, operationId, restricted,
-                options, cookie, requireConfirmation, logger, biometricContext,
-                isStrongBiometric, null /* taskStackListener */,
-                lockoutTracker, allowBackgroundAuthentication, true /* shouldVibrate */,
-                sensorStrength);
-        setRequestId(requestId);
-        mUsageStats = usageStats;
-
-        final Resources resources = getContext().getResources();
-        mBiometricPromptIgnoreList = resources.getIntArray(
-                R.array.config_face_acquire_biometricprompt_ignorelist);
-        mBiometricPromptIgnoreListVendor = resources.getIntArray(
-                R.array.config_face_acquire_vendor_biometricprompt_ignorelist);
-        mKeyguardIgnoreList = resources.getIntArray(
-                R.array.config_face_acquire_keyguard_ignorelist);
-        mKeyguardIgnoreListVendor = resources.getIntArray(
-                R.array.config_face_acquire_vendor_keyguard_ignorelist);
-    }
-
-    @Override
-    public void start(@NonNull ClientMonitorCallback callback) {
-        super.start(callback);
-        mState = STATE_STARTED;
-    }
-
-    @NonNull
-    @Override
-    protected ClientMonitorCallback wrapCallbackForStart(@NonNull ClientMonitorCallback callback) {
-        return new ClientMonitorCompositeCallback(
-                getLogger().getAmbientLightProbe(true /* startWithClient */), callback);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().authenticate(mOperationId);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting auth", e);
-            onError(BiometricFaceConstants.FACE_ERROR_HW_UNAVAILABLE, 0 /* vendorCode */);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    @Override
-    protected void stopHalOperation() {
-        try {
-            getFreshDaemon().cancel();
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting cancel", e);
-            onError(BiometricFaceConstants.FACE_ERROR_HW_UNAVAILABLE, 0 /* vendorCode */);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    @Override
-    public boolean wasUserDetected() {
-        // Do not provide haptic feedback if the user was not detected, and an error (usually
-        // ERROR_TIMEOUT) is received.
-        return mLastAcquire != FaceManager.FACE_ACQUIRED_NOT_DETECTED
-                && mLastAcquire != FaceManager.FACE_ACQUIRED_SENSOR_DIRTY;
-    }
-
-    @Override
-    protected void handleLifecycleAfterAuth(boolean authenticated) {
-        // For face, the authentication lifecycle ends either when
-        // 1) Authenticated == true
-        // 2) Error occurred
-        // 3) Authenticated == false
-        mCallback.onClientFinished(this, true /* success */);
-    }
-
-    @Override
-    public @LockoutTracker.LockoutMode int handleFailedAttempt(int userId) {
-        @LockoutTracker.LockoutMode final int lockoutMode =
-                getLockoutTracker().getLockoutModeForUser(userId);
-        final PerformanceTracker performanceTracker =
-                PerformanceTracker.getInstanceForSensorId(getSensorId());
-        if (lockoutMode == LockoutTracker.LOCKOUT_PERMANENT) {
-            performanceTracker.incrementPermanentLockoutForUser(userId);
-        } else if (lockoutMode == LockoutTracker.LOCKOUT_TIMED) {
-            performanceTracker.incrementTimedLockoutForUser(userId);
-        }
-
-        return lockoutMode;
-    }
-
-    @Override
-    public void onAuthenticated(BiometricAuthenticator.Identifier identifier,
-            boolean authenticated, ArrayList<Byte> token) {
-        super.onAuthenticated(identifier, authenticated, token);
-
-        mState = STATE_STOPPED;
-        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(
-                getStartTimeMs(),
-                System.currentTimeMillis() - getStartTimeMs() /* latency */,
-                authenticated,
-                0 /* error */,
-                0 /* vendorError */,
-                getTargetUserId()));
-    }
-
-    @Override
-    public void onError(@BiometricConstants.Errors int error, int vendorCode) {
-        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(
-                getStartTimeMs(),
-                System.currentTimeMillis() - getStartTimeMs() /* latency */,
-                false /* authenticated */,
-                error,
-                vendorCode,
-                getTargetUserId()));
-
-        super.onError(error, vendorCode);
-    }
-
-    private int[] getAcquireIgnorelist() {
-        return isBiometricPrompt() ? mBiometricPromptIgnoreList : mKeyguardIgnoreList;
-    }
-
-    private int[] getAcquireVendorIgnorelist() {
-        return isBiometricPrompt() ? mBiometricPromptIgnoreListVendor : mKeyguardIgnoreListVendor;
-    }
-
-    private boolean shouldSend(int acquireInfo, int vendorCode) {
-        if (acquireInfo == FaceManager.FACE_ACQUIRED_VENDOR) {
-            return !Utils.listContains(getAcquireVendorIgnorelist(), vendorCode);
-        } else {
-            return !Utils.listContains(getAcquireIgnorelist(), acquireInfo);
-        }
-    }
-
-    @Override
-    public void onAcquired(int acquireInfo, int vendorCode) {
-        mLastAcquire = acquireInfo;
-
-        if (acquireInfo == FaceManager.FACE_ACQUIRED_RECALIBRATE) {
-            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
-        }
-        @LockoutTracker.LockoutMode final int lockoutMode =
-                getLockoutTracker().getLockoutModeForUser(getTargetUserId());
-        if (lockoutMode == LockoutTracker.LOCKOUT_NONE) {
-            PerformanceTracker pt = PerformanceTracker.getInstanceForSensorId(getSensorId());
-            pt.incrementAcquireForUser(getTargetUserId(), isCryptoOperation());
-        }
-
-        final boolean shouldSend = shouldSend(acquireInfo, vendorCode);
-        onAcquiredInternal(acquireInfo, vendorCode, shouldSend);
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceEnrollClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceEnrollClient.java
deleted file mode 100644
index 38c011253302..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceEnrollClient.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.content.Context;
-import android.hardware.biometrics.BiometricFaceConstants;
-import android.hardware.face.Face;
-import android.hardware.face.FaceManager;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-import android.view.Surface;
-
-import com.android.internal.R;
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.ClientMonitorCompositeCallback;
-import com.android.server.biometrics.sensors.EnrollClient;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceEnrollClient extends EnrollClient<ISenseService> {
-
-    private static final String TAG = "FaceEnrollClient";
-
-    @NonNull private final int[] mDisabledFeatures;
-    @NonNull private final int[] mEnrollIgnoreList;
-    @NonNull private final int[] mEnrollIgnoreListVendor;
-
-    FaceEnrollClient(@NonNull Context context, @NonNull Supplier<ISenseService> lazyDaemon,
-            @NonNull IBinder token, @NonNull ClientMonitorCallbackConverter listener, int userId,
-            @NonNull byte[] hardwareAuthToken, @NonNull String owner, long requestId,
-            @NonNull BiometricUtils<Face> utils, @NonNull int[] disabledFeatures, int timeoutSec,
-            @Nullable Surface previewSurface, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext) {
-        super(context, lazyDaemon, token, listener, userId, hardwareAuthToken, owner, utils,
-                timeoutSec, sensorId, false /* shouldVibrate */, logger, biometricContext);
-        setRequestId(requestId);
-        mDisabledFeatures = Arrays.copyOf(disabledFeatures, disabledFeatures.length);
-        mEnrollIgnoreList = getContext().getResources()
-                .getIntArray(R.array.config_face_acquire_enroll_ignorelist);
-        mEnrollIgnoreListVendor = getContext().getResources()
-                .getIntArray(R.array.config_face_acquire_vendor_enroll_ignorelist);
-    }
-
-    @NonNull
-    @Override
-    protected ClientMonitorCallback wrapCallbackForStart(@NonNull ClientMonitorCallback callback) {
-        return new ClientMonitorCompositeCallback(
-                getLogger().getAmbientLightProbe(true /* startWithClient */), callback);
-    }
-
-    @Override
-    protected boolean hasReachedEnrollmentLimit() {
-        final int limit = getContext().getResources().getInteger(
-                com.android.internal.R.integer.config_faceMaxTemplatesPerUser);
-        final int enrolled = mBiometricUtils.getBiometricsForUser(getContext(), getTargetUserId())
-                .size();
-        if (enrolled >= limit) {
-            Slog.w(TAG, "Too many faces registered, user: " + getTargetUserId());
-            return true;
-        }
-        return false;
-    }
-
-    @Override
-    public void onAcquired(int acquireInfo, int vendorCode) {
-        final boolean shouldSend;
-        if (acquireInfo == FaceManager.FACE_ACQUIRED_VENDOR) {
-            shouldSend = !Utils.listContains(mEnrollIgnoreListVendor, vendorCode);
-        } else {
-            shouldSend = !Utils.listContains(mEnrollIgnoreList, acquireInfo);
-        }
-        onAcquiredInternal(acquireInfo, vendorCode, shouldSend);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        final ArrayList<Byte> token = new ArrayList<>();
-        for (byte b : mHardwareAuthToken) {
-            token.add(Byte.valueOf(b));
-        }
-        final ArrayList<Integer> disabledFeatures = new ArrayList<>();
-        for (int disabledFeature : mDisabledFeatures) {
-            disabledFeatures.add(disabledFeature);
-        }
-
-        try {
-            getFreshDaemon().enroll(SenseUtils.toByteArray(token), mTimeoutSec, SenseUtils.toIntArray(disabledFeatures));
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting enroll", e);
-            onError(BiometricFaceConstants.FACE_ERROR_UNABLE_TO_PROCESS, 0 /* vendorCode */);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    @Override
-    protected void stopHalOperation() {
-        try {
-            getFreshDaemon().cancel();
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting cancel", e);
-            onError(BiometricFaceConstants.FACE_ERROR_HW_UNAVAILABLE, 0 /* vendorCode */);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceGenerateChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceGenerateChallengeClient.java
deleted file mode 100644
index 9a9414ff9449..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceGenerateChallengeClient.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.hardware.face.IFaceServiceReceiver;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.Preconditions;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.GenerateChallengeClient;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceGenerateChallengeClient extends GenerateChallengeClient<ISenseService> {
-
-    private static final String TAG = "FaceGenerateChallengeClient";
-    static final int CHALLENGE_TIMEOUT_SEC = 600; // 10 minutes
-    private static final ClientMonitorCallback EMPTY_CALLBACK = new ClientMonitorCallback() {
-    };
-
-    private final long mCreatedAt;
-    private List<IFaceServiceReceiver> mWaiting;
-    private Long mChallengeResult;
-
-    FaceGenerateChallengeClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon, @NonNull IBinder token,
-            @NonNull ClientMonitorCallbackConverter listener, int userId, @NonNull String owner,
-            int sensorId, @NonNull BiometricLogger logger,
-            @NonNull BiometricContext biometricContext, long now) {
-        super(context, lazyDaemon, token, listener, userId, owner, sensorId, logger,
-                biometricContext);
-        mCreatedAt = now;
-        mWaiting = new ArrayList<>();
-    }
-
-    @Override
-    protected void startHalOperation() {
-        mChallengeResult = null;
-        try {
-            mChallengeResult = Long.valueOf(getFreshDaemon().generateChallenge(CHALLENGE_TIMEOUT_SEC));
-            // send the result to the original caller via mCallback and any waiting callers
-            // that called reuseResult
-            sendChallengeResult(getListener(), mCallback);
-            for (IFaceServiceReceiver receiver : mWaiting) {
-                sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
-            }
-        } catch (RemoteException e) {
-            Slog.e(TAG, "generateChallenge failed", e);
-            mCallback.onClientFinished(this, false /* success */);
-        } finally {
-            mWaiting = null;
-        }
-    }
-
-    /** @return An arbitrary time value for caching provided to the constructor. */
-    public long getCreatedAt() {
-        return mCreatedAt;
-    }
-
-    /**
-     * Reuse the result of this operation when it is available. The receiver will be notified
-     * immediately if a challenge has already been generated.
-     *
-     * @param receiver receiver to be notified of challenge result
-     */
-    public void reuseResult(@NonNull IFaceServiceReceiver receiver) {
-        if (mWaiting != null) {
-            mWaiting.add(receiver);
-        } else {
-            sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
-        }
-    }
-
-    private void sendChallengeResult(@NonNull ClientMonitorCallbackConverter receiver,
-            @NonNull ClientMonitorCallback ownerCallback) {
-        Preconditions.checkState(mChallengeResult != null, "result not available");
-        try {
-            receiver.onChallengeGenerated(getSensorId(), getTargetUserId(), mChallengeResult);
-            ownerCallback.onClientFinished(this, true /* success */);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception", e);
-            ownerCallback.onClientFinished(this, false /* success */);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceGetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceGetFeatureClient.java
deleted file mode 100644
index fc3b8223a967..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceGetFeatureClient.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.content.Context;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.BiometricsProto;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceGetFeatureClient extends HalClientMonitor<ISenseService> {
-
-    private static final String TAG = "FaceGetFeatureClient";
-
-    private final int mFeature;
-    private final int mFaceId;
-    private boolean mValue;
-
-    FaceGetFeatureClient(@NonNull Context context, @NonNull Supplier<ISenseService> lazyDaemon,
-            @NonNull IBinder token, @Nullable ClientMonitorCallbackConverter listener, int userId,
-            @NonNull String owner, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext,
-            int feature, int faceId) {
-        super(context, lazyDaemon, token, listener, userId, owner, 0 /* cookie */, sensorId,
-                logger, biometricContext);
-        mFeature = feature;
-        mFaceId = faceId;
-    }
-
-    @Override
-    public void unableToStart() {
-        try {
-            if (getListener() != null) {
-                getListener().onFeatureGet(false /* success */, new int[0], new boolean[0]);
-            }
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to send error", e);
-        }
-    }
-
-    @Override
-    public void start(@NonNull ClientMonitorCallback callback) {
-        super.start(callback);
-        startHalOperation();
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            final boolean result = getFreshDaemon().getFeature(mFeature, mFaceId);
-            int[] features = new int[1];
-            features[0] = mFeature;
-            boolean[] featureState = {result};
-            mValue = result;
-
-            if (getListener() != null) {
-                getListener().onFeatureGet(result, features, featureState);
-            }
-            mCallback.onClientFinished(this, true /* success */);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to getFeature", e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    boolean getValue() {
-        return mValue;
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return BiometricsProto.CM_GET_FEATURE;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceInternalCleanupClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceInternalCleanupClient.java
deleted file mode 100644
index bd696fd60a8d..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceInternalCleanupClient.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.InternalCleanupClient;
-import com.android.server.biometrics.sensors.InternalEnumerateClient;
-import com.android.server.biometrics.sensors.RemovalClient;
-
-import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-class FaceInternalCleanupClient extends InternalCleanupClient<Face, ISenseService> {
-
-    FaceInternalCleanupClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon, int userId, @NonNull String owner,
-            int sensorId, @NonNull BiometricLogger logger,
-            @NonNull BiometricContext biometricContext,
-            @NonNull BiometricUtils<Face> utils, @NonNull Map<Integer, Long> authenticatorIds) {
-        super(context, lazyDaemon, userId, owner, sensorId, logger, biometricContext,
-                utils, authenticatorIds);
-    }
-
-    @Override
-    protected InternalEnumerateClient<ISenseService> getEnumerateClient(Context context,
-            Supplier<ISenseService> lazyDaemon, IBinder token, int userId, String owner,
-            List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext) {
-        return new FaceInternalEnumerateClient(context, lazyDaemon, token, userId, owner,
-                enrolledList, utils, sensorId, logger, biometricContext);
-    }
-
-    @Override
-    protected RemovalClient<Face, ISenseService> getRemovalClient(Context context,
-            Supplier<ISenseService> lazyDaemon, IBinder token,
-            int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext,
-            Map<Integer, Long> authenticatorIds) {
-        // Internal remove does not need to send results to anyone. Cleanup (enumerate + remove)
-        // is all done internally.
-        return new FaceRemovalClient(context, lazyDaemon, token,
-                null /* ClientMonitorCallbackConverter */, biometricId, userId, owner, utils,
-                sensorId, logger, biometricContext, authenticatorIds);
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceInternalEnumerateClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceInternalEnumerateClient.java
deleted file mode 100644
index c9f0a028a8bb..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceInternalEnumerateClient.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.InternalEnumerateClient;
-
-import java.util.List;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-class FaceInternalEnumerateClient extends InternalEnumerateClient<ISenseService> {
-    private static final String TAG = "FaceInternalEnumerateClient";
-
-    FaceInternalEnumerateClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon, @NonNull IBinder token, int userId,
-            @NonNull String owner, @NonNull List<Face> enrolledList,
-            @NonNull BiometricUtils<Face> utils, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext) {
-        super(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId,
-                logger, biometricContext);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().enumerate();
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting enumerate", e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceRemovalClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceRemovalClient.java
deleted file mode 100644
index 93e72863fac8..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceRemovalClient.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.RemovalClient;
-
-import java.util.Map;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-class FaceRemovalClient extends RemovalClient<Face, ISenseService> {
-    private static final String TAG = "FaceRemovalClient";
-
-    private final int mBiometricId;
-
-    FaceRemovalClient(@NonNull Context context, @NonNull Supplier<ISenseService> lazyDaemon,
-            @NonNull IBinder token, @NonNull ClientMonitorCallbackConverter listener,
-            int biometricId, int userId, @NonNull String owner, @NonNull BiometricUtils<Face> utils,
-            int sensorId, @NonNull BiometricLogger logger,
-            @NonNull BiometricContext biometricContext,
-            @NonNull Map<Integer, Long> authenticatorIds) {
-        super(context, lazyDaemon, token, listener, userId, owner, utils, sensorId, logger,
-                biometricContext, authenticatorIds);
-        mBiometricId = biometricId;
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().remove(mBiometricId);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting remove", e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceResetLockoutClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceResetLockoutClient.java
deleted file mode 100644
index ab791d0be4df..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceResetLockoutClient.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.BiometricsProto;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-
-import java.util.ArrayList;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceResetLockoutClient extends HalClientMonitor<ISenseService> {
-
-    private static final String TAG = "FaceResetLockoutClient";
-
-    private final byte[] mHardwareAuthToken;
-
-    FaceResetLockoutClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon, int userId, String owner, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext,
-            @NonNull byte[] hardwareAuthToken) {
-        super(context, lazyDaemon, null /* token */, null /* listener */, userId, owner,
-                0 /* cookie */, sensorId, logger, biometricContext);
-
-        mHardwareAuthToken = (byte[]) hardwareAuthToken.clone();
-    }
-
-    @Override
-    public void unableToStart() {
-        // Nothing to do here
-    }
-
-    @Override
-    public void start(@NonNull ClientMonitorCallback callback) {
-        super.start(callback);
-        startHalOperation();
-    }
-
-    public boolean interruptsPrecedingClients() {
-        return true;
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().resetLockout(mHardwareAuthToken);
-            mCallback.onClientFinished(this, true /* success */);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to reset lockout", e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return BiometricsProto.CM_RESET_LOCKOUT;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceRevokeChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceRevokeChallengeClient.java
deleted file mode 100644
index 7f42df49d0d9..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceRevokeChallengeClient.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.RevokeChallengeClient;
-
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceRevokeChallengeClient extends RevokeChallengeClient<ISenseService> {
-
-    private static final String TAG = "FaceRevokeChallengeClient";
-
-    FaceRevokeChallengeClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon, @NonNull IBinder token,
-            int userId, @NonNull String owner, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext) {
-        super(context, lazyDaemon, token, userId, owner, sensorId, logger, biometricContext);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().revokeChallenge();
-            mCallback.onClientFinished(this, true /* success */);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "revokeChallenge failed", e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceSetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceSetFeatureClient.java
deleted file mode 100644
index 65f17d5abf73..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceSetFeatureClient.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.BiometricsProto;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-
-import java.util.ArrayList;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceSetFeatureClient extends HalClientMonitor<ISenseService> {
-
-    private static final String TAG = "FaceSetFeatureClient";
-
-    private final int mFeature;
-    private final boolean mEnabled;
-    private final byte[] mHardwareAuthToken;
-    private final int mFaceId;
-
-    FaceSetFeatureClient(@NonNull Context context, @NonNull Supplier<ISenseService> lazyDaemon,
-            @NonNull IBinder token, @NonNull ClientMonitorCallbackConverter listener, int userId,
-            @NonNull String owner, int sensorId,
-            @NonNull BiometricLogger logger, @NonNull BiometricContext biometricContext,
-            int feature, boolean enabled, byte[] hardwareAuthToken, int faceId) {
-        super(context, lazyDaemon, token, listener, userId, owner, 0 /* cookie */, sensorId,
-                logger, biometricContext);
-        mFeature = feature;
-        mEnabled = enabled;
-        mFaceId = faceId;
-
-        mHardwareAuthToken = (byte[]) hardwareAuthToken.clone();
-    }
-
-    @Override
-    public void unableToStart() {
-        try {
-            getListener().onFeatureSet(false /* success */, mFeature);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to send error", e);
-        }
-    }
-
-    @Override
-    public void start(@NonNull ClientMonitorCallback callback) {
-        super.start(callback);
-
-        startHalOperation();
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().setFeature(mFeature, mEnabled, mHardwareAuthToken, mFaceId);
-            getListener().onFeatureSet(true, mFeature);
-            mCallback.onClientFinished(this, true /* success */);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to set feature: " + mFeature + " to enabled: " + mEnabled, e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return BiometricsProto.CM_SET_FEATURE;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceUpdateActiveUserClient.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceUpdateActiveUserClient.java
deleted file mode 100644
index 08c075067082..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/FaceUpdateActiveUserClient.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.os.Environment;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.BiometricsProto;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-
-import java.io.File;
-import java.util.Map;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-
-public class FaceUpdateActiveUserClient extends HalClientMonitor<ISenseService> {
-    private static final String TAG = "FaceUpdateActiveUserClient";
-    private static final String FACE_DATA_DIR = "facedata";
-
-    private final boolean mHasEnrolledBiometrics;
-    @NonNull private final Map<Integer, Long> mAuthenticatorIds;
-
-    FaceUpdateActiveUserClient(@NonNull Context context,
-            @NonNull Supplier<ISenseService> lazyDaemon, int userId, @NonNull String owner,
-            int sensorId, @NonNull BiometricLogger logger,
-            @NonNull BiometricContext biometricContext, boolean hasEnrolledBiometrics,
-            @NonNull Map<Integer, Long> authenticatorIds) {
-        super(context, lazyDaemon, null /* token */, null /* listener */, userId, owner,
-                0 /* cookie */, sensorId, logger, biometricContext);
-        mHasEnrolledBiometrics = hasEnrolledBiometrics;
-        mAuthenticatorIds = authenticatorIds;
-    }
-
-    @Override
-    public void start(@NonNull ClientMonitorCallback callback) {
-        super.start(callback);
-        startHalOperation();
-    }
-
-    @Override
-    public void unableToStart() {
-        // Nothing to do here
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            final ISenseService daemon = getFreshDaemon();
-            mAuthenticatorIds.put(getTargetUserId(),
-                    mHasEnrolledBiometrics ? daemon.getAuthenticatorId() : 0L);
-            mCallback.onClientFinished(this, true /* success */);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Failed to setActiveUser: " + e);
-            mCallback.onClientFinished(this, false /* success */);
-        }
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return BiometricsProto.CM_UPDATE_ACTIVE_USER;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/SenseProvider.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/SenseProvider.java
deleted file mode 100644
index a5c077b357c6..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/SenseProvider.java
+++ /dev/null
@@ -1,1107 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.app.ActivityManager;
-import android.app.SynchronousUserSwitchObserver;
-import android.app.UserSwitchObserver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.pm.UserInfo;
-import android.hardware.biometrics.BiometricConstants;
-import android.hardware.biometrics.BiometricFaceConstants;
-import android.hardware.biometrics.BiometricsProtoEnums;
-import android.hardware.biometrics.ITestSession;
-import android.hardware.biometrics.ITestSessionCallback;
-import android.hardware.biometrics.face.V1_0.IBiometricsFace;
-import android.hardware.face.Face;
-import android.hardware.face.FaceAuthenticateOptions;
-import android.hardware.face.FaceSensorPropertiesInternal;
-import android.hardware.face.IFaceServiceReceiver;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.RemoteException;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.Settings;
-import android.util.Slog;
-import android.util.SparseArray;
-import android.util.proto.ProtoOutputStream;
-import android.view.Surface;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.server.biometrics.AuthenticationStatsCollector;
-import com.android.server.biometrics.SensorServiceStateProto;
-import com.android.server.biometrics.SensorStateProto;
-import com.android.server.biometrics.UserStateProto;
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.AcquisitionClient;
-import com.android.server.biometrics.sensors.AuthenticationConsumer;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.AuthenticationStatsBroadcastReceiver;
-import com.android.server.biometrics.sensors.BiometricNotificationUtils;
-import com.android.server.biometrics.sensors.BiometricScheduler;
-import com.android.server.biometrics.sensors.BiometricStateCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.ClientMonitorCompositeCallback;
-import com.android.server.biometrics.sensors.EnumerateConsumer;
-import com.android.server.biometrics.sensors.ErrorConsumer;
-import com.android.server.biometrics.sensors.LockoutResetDispatcher;
-import com.android.server.biometrics.sensors.LockoutTracker;
-import com.android.server.biometrics.sensors.PerformanceTracker;
-import com.android.server.biometrics.sensors.RemovalConsumer;
-import com.android.server.biometrics.sensors.face.FaceUtils;
-import com.android.server.biometrics.sensors.face.LockoutHalImpl;
-import com.android.server.biometrics.sensors.face.ServiceProvider;
-import com.android.server.biometrics.sensors.face.UsageStats;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.FileDescriptor;
-import java.io.PrintWriter;
-import java.time.Clock;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.Supplier;
-
-import vendor.aospa.biometrics.face.ISenseService;
-import vendor.aospa.biometrics.face.ISenseServiceReceiver;
-
-public class SenseProvider implements ServiceProvider {
-
-    private static final String TAG = "SenseProvider";
-
-    private static final String BIND_SENSE_ACTION = "co.aospa.sense.BIND";
-    private static final String PACKAGE_NAME = "co.aospa.sense";
-    private static final String SERVICE_NAME = "co.aospa.sense.SenseService";
-
-    public static final int DEVICE_ID = 1008;
-    private static final int ENROLL_TIMEOUT_SEC = 75;
-    private static final int GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS = 60 * 1000;
-    private static final int GENERATE_CHALLENGE_COUNTER_TTL_MILLIS =
-            FaceGenerateChallengeClient.CHALLENGE_TIMEOUT_SEC * 1000;
-    @VisibleForTesting
-    public static Clock sSystemClock = Clock.systemUTC();
-
-    private boolean mIsBinding;
-    private boolean mTestHalEnabled;
-
-    @NonNull private final FaceSensorPropertiesInternal mSensorProperties;
-    @NonNull private final BiometricStateCallback mBiometricStateCallback;
-    @NonNull private final Context mContext;
-    @NonNull private final BiometricScheduler mScheduler;
-    @NonNull private final Handler mHandler;
-    @NonNull private final Supplier<ISenseService> mLazyDaemon;
-    @NonNull private final LockoutHalImpl mLockoutTracker;
-    @NonNull private final UsageStats mUsageStats;
-    @NonNull private final Map<Integer, Long> mAuthenticatorIds;
-    @Nullable private IBiometricsFace mDaemon;
-    @NonNull private final HalResultController mHalResultController;
-    @NonNull private final BiometricContext mBiometricContext;
-    @Nullable private AuthenticationStatsCollector mAuthenticationStatsCollector;
-    SparseArray<ISenseService> mServices;
-    // for requests that do not use biometric prompt
-    @NonNull private final AtomicLong mRequestCounter = new AtomicLong(0);
-    private int mCurrentUserId = UserHandle.USER_NULL;
-    private final int mSensorId;
-    private final List<Long> mGeneratedChallengeCount = new ArrayList<>();
-    private FaceGenerateChallengeClient mGeneratedChallengeCache = null;
-
-    private final UserSwitchObserver mUserSwitchObserver = new SynchronousUserSwitchObserver() {
-        @Override
-        public void onUserSwitching(int newUserId) {
-            mCurrentUserId = newUserId;
-            ISenseService service = getDaemon();
-            if (service == null) {
-                bindService(mCurrentUserId);
-            }
-        }
-    };
-
-    public static class HalResultController extends ISenseServiceReceiver.Stub {
-        /**
-         * Interface to sends results to the HalResultController's owner.
-         */
-        public interface Callback {
-            /**
-             * Invoked when the HAL sends ERROR_HW_UNAVAILABLE.
-             */
-            void onHardwareUnavailable();
-        }
-
-        private final int mSensorId;
-        @NonNull private final Context mContext;
-        @NonNull private final Handler mHandler;
-        @NonNull private final BiometricScheduler mScheduler;
-        @Nullable private Callback mCallback;
-        @NonNull private final LockoutHalImpl mLockoutTracker;
-        @NonNull private final LockoutResetDispatcher mLockoutResetDispatcher;
-
-
-        HalResultController(int sensorId, @NonNull Context context, @NonNull Handler handler,
-                @NonNull BiometricScheduler scheduler, @NonNull LockoutHalImpl lockoutTracker,
-                @NonNull LockoutResetDispatcher lockoutResetDispatcher) {
-            mSensorId = sensorId;
-            mContext = context;
-            mHandler = handler;
-            mScheduler = scheduler;
-            mLockoutTracker = lockoutTracker;
-            mLockoutResetDispatcher = lockoutResetDispatcher;
-        }
-
-        public void setCallback(@Nullable Callback callback) {
-            mCallback = callback;
-        }
-
-        @Override
-        public void onEnrollResult(int faceId, int userId, int remaining) {
-            mHandler.post(() -> {
-                final CharSequence name = FaceUtils.getLegacyInstance(mSensorId)
-                        .getUniqueName(mContext, userId);
-                final Face face = new Face(name, faceId, Long.valueOf(DEVICE_ID));
-
-                final BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof FaceEnrollClient)) {
-                    Slog.e(TAG, "onEnrollResult for non-enroll client: "
-                            + Utils.getClientName(client));
-                    return;
-                }
-
-                final FaceEnrollClient enrollClient = (FaceEnrollClient) client;
-                enrollClient.onEnrollResult(face, remaining);
-            });
-        }
-
-        @Override
-        public void onAuthenticated(int faceId, int userId, byte[] token) {
-            mHandler.post(() -> {
-                final BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof AuthenticationConsumer)) {
-                    Slog.e(TAG, "onAuthenticated for non-authentication consumer: "
-                            + Utils.getClientName(client));
-                    return;
-                }
-
-                final AuthenticationConsumer authenticationConsumer =
-                        (AuthenticationConsumer) client;
-                final boolean authenticated = faceId != 0;
-                final Face face = new Face("", faceId, DEVICE_ID);
-                authenticationConsumer.onAuthenticated(face, authenticated, SenseUtils.toByteArrayList(token));
-            });
-        }
-
-        @Override
-        public void onAcquired(int userId, int acquiredInfo, int vendorCode) {
-            mHandler.post(() -> {
-                final BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof AcquisitionClient)) {
-                    Slog.e(TAG, "onAcquired for non-acquire client: "
-                            + Utils.getClientName(client));
-                    return;
-                }
-
-                final AcquisitionClient<?> acquisitionClient =
-                        (AcquisitionClient<?>) client;
-                acquisitionClient.onAcquired(acquiredInfo, vendorCode);
-            });
-        }
-
-        @Override
-        public void onError(int error, int vendorCode) {
-            mHandler.post(() -> {
-                final BaseClientMonitor client = mScheduler.getCurrentClient();
-                Slog.d(TAG, "handleError"
-                        + ", client: " + (client != null ? client.getOwnerString() : null)
-                        + ", error: " + error
-                        + ", vendorCode: " + vendorCode);
-                if (!(client instanceof ErrorConsumer)) {
-                    Slog.e(TAG, "onError for non-error consumer: " + Utils.getClientName(
-                            client));
-                    return;
-                }
-
-                final ErrorConsumer errorConsumer = (ErrorConsumer) client;
-                errorConsumer.onError(error, vendorCode);
-
-                if (error == BiometricConstants.BIOMETRIC_ERROR_HW_UNAVAILABLE) {
-                    Slog.e(TAG, "Got ERROR_HW_UNAVAILABLE");
-                    if (mCallback != null) {
-                        mCallback.onHardwareUnavailable();
-                    }
-                }
-            });
-        }
-
-        @Override
-        public void onRemoved(int[] faceIds, int userId) {
-            mHandler.post(() -> {
-                final BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof RemovalConsumer)) {
-                    Slog.e(TAG, "onRemoved for non-removal consumer: "
-                            + Utils.getClientName(client));
-                    return;
-                }
-
-                final RemovalConsumer removalConsumer = (RemovalConsumer) client;
-
-                if (faceIds.length > 0) {
-                    // Convert to old fingerprint-like behavior, where remove() receives
-                    // one removal at a time. This way, remove can share some more common code.
-                    for (int i = 0; i < faceIds.length; i++) {
-                        final int id = faceIds[i];
-                        final Face face = new Face("", id, Long.valueOf(DEVICE_ID));
-                        final int remaining = (faceIds.length - i) - 1;
-                        Slog.d(TAG, "Removed, faceId: " + id + ", remaining: " + remaining);
-                        removalConsumer.onRemoved(face, remaining);
-                    }
-                } else {
-                    removalConsumer.onRemoved(null, 0 /* remaining */);
-                }
-
-                Settings.Secure.putIntForUser(mContext.getContentResolver(),
-                        Settings.Secure.FACE_UNLOCK_RE_ENROLL, 0, UserHandle.USER_CURRENT);
-            });
-        }
-
-        @Override
-        public void onEnumerate(int[] faceIds, int userId) {
-            mHandler.post(() -> {
-                final BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof EnumerateConsumer)) {
-                    Slog.e(TAG, "onEnumerate for non-enumerate consumer: "
-                            + Utils.getClientName(client));
-                    return;
-                }
-
-                final EnumerateConsumer enumerateConsumer = (EnumerateConsumer) client;
-
-                if (faceIds.length > 0) {
-                    // Convert to old fingerprint-like behavior, where enumerate() receives one
-                    // template at a time. This way, enumerate can share some more common code.
-                    for (int i = 0; i < faceIds.length; i++) {
-                        final Face face = new Face("", faceIds[i], Long.valueOf(DEVICE_ID));
-                        enumerateConsumer.onEnumerationResult(face, (faceIds.length - i) - 1);
-                    }
-                } else {
-                    // For face, the HIDL contract is to receive an empty list when there are no
-                    // templates enrolled. Send a null identifier since we don't consume them
-                    // anywhere, and send remaining == 0 so this code can be shared with Face@1.1
-                    enumerateConsumer.onEnumerationResult(null /* identifier */, 0);
-                }
-            });
-        }
-
-        @Override
-        public void onLockoutChanged(long duration) {
-            mHandler.post(() -> {
-                Slog.d(TAG, "onLockoutChanged: " + duration);
-                final @LockoutTracker.LockoutMode int lockoutMode;
-                if (duration == 0) {
-                    lockoutMode = LockoutTracker.LOCKOUT_NONE;
-                } else if (duration == -1 || duration == Long.MAX_VALUE) {
-                    lockoutMode = LockoutTracker.LOCKOUT_PERMANENT;
-                } else {
-                    lockoutMode = LockoutTracker.LOCKOUT_TIMED;
-                }
-
-                mLockoutTracker.setCurrentUserLockoutMode(lockoutMode);
-
-                if (duration == 0) {
-                    mLockoutResetDispatcher.notifyLockoutResetCallbacks(mSensorId);
-                }
-            });
-        }
-    }
-
-    @VisibleForTesting
-    public SenseProvider(@NonNull Context context,
-            @NonNull BiometricStateCallback biometricStateCallback,
-            @NonNull FaceSensorPropertiesInternal sensorProps,
-            @NonNull LockoutResetDispatcher lockoutResetDispatcher,
-            @NonNull BiometricScheduler scheduler) {
-        mServices = new SparseArray<>();
-        mIsBinding = false;
-        mSensorProperties = sensorProps;
-        mContext = context;
-        mBiometricStateCallback = biometricStateCallback;
-        mSensorId = sensorProps.sensorId;
-        mScheduler = scheduler;
-        mHandler = new Handler(Looper.getMainLooper());
-        mBiometricContext = BiometricContext.getInstance(context);
-        mUsageStats = new UsageStats(context);
-        mAuthenticatorIds = new HashMap<>();
-        mLazyDaemon = SenseProvider.this::getDaemon;
-        mLockoutTracker = new LockoutHalImpl();
-        mHalResultController = new HalResultController(sensorProps.sensorId, context, mHandler,
-                mScheduler, mLockoutTracker, lockoutResetDispatcher);
-        mHalResultController.setCallback(() -> {
-            mDaemon = null;
-            mCurrentUserId = UserHandle.USER_NULL;
-        });
-        mCurrentUserId = ActivityManager.getCurrentUser();
-
-        AuthenticationStatsBroadcastReceiver mBroadcastReceiver =
-                new AuthenticationStatsBroadcastReceiver(
-                        mContext,
-                        BiometricsProtoEnums.MODALITY_FACE,
-                        (AuthenticationStatsCollector collector) -> {
-                            Slog.d(TAG, "Initializing AuthenticationStatsCollector");
-                            mAuthenticationStatsCollector = collector;
-                        });
-
-        try {
-            ActivityManager.getService().registerUserSwitchObserver(mUserSwitchObserver, TAG);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to register user switch observer");
-        }
-    }
-
-    public SenseProvider(Context context, BiometricStateCallback biometricStateCallback, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher) {
-        this(context, biometricStateCallback, sensorProps, lockoutResetDispatcher, new BiometricScheduler(context, TAG, 0, null));
-    }
-
-    private synchronized ISenseService getDaemon() {
-        if (mTestHalEnabled) {
-            final TestHal testHal = new TestHal(mContext, mSensorId);
-            testHal.setCallback(mHalResultController);
-            return testHal;
-        }
-
-        ISenseService service = getService(mCurrentUserId);
-        if (service == null) {
-            bindService(mCurrentUserId);
-        }
-        return service;
-    }
-
-    @Override
-    public boolean containsSensor(int sensorId) {
-        return mSensorId == sensorId;
-    }
-
-    @Override
-    @NonNull
-    public List<FaceSensorPropertiesInternal> getSensorProperties() {
-        final List<FaceSensorPropertiesInternal> properties = new ArrayList<>();
-        properties.add(mSensorProperties);
-        return properties;
-    }
-
-    @NonNull
-    @Override
-    public FaceSensorPropertiesInternal getSensorProperties(int sensorId) {
-        return mSensorProperties;
-    }
-
-    @Override
-    @NonNull
-    public List<Face> getEnrolledFaces(int sensorId, int userId) {
-        return FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
-    }
-
-    @Override
-    public boolean hasEnrollments(int sensorId, int userId) {
-        return !getEnrolledFaces(sensorId, userId).isEmpty();
-    }
-
-    @Override
-    @LockoutTracker.LockoutMode
-    public int getLockoutModeForUser(int sensorId, int userId) {
-        return mLockoutTracker.getLockoutModeForUser(userId);
-    }
-
-    @Override
-    public long getAuthenticatorId(int sensorId, int userId) {
-        return mAuthenticatorIds.getOrDefault(userId, 0L);
-    }
-
-    @Override
-    public boolean isHardwareDetected(int sensorId) {
-        return getDaemon() != null;
-    }
-
-    private boolean isGeneratedChallengeCacheValid() {
-        return mGeneratedChallengeCache != null
-                && sSystemClock.millis() - mGeneratedChallengeCache.getCreatedAt()
-                < GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS;
-    }
-
-    private void incrementChallengeCount() {
-        mGeneratedChallengeCount.add(0, sSystemClock.millis());
-    }
-
-    private int decrementChallengeCount() {
-        final long now = sSystemClock.millis();
-        // ignore values that are old in case generate/revoke calls are not matched
-        // this doesn't ensure revoke if calls are mismatched but it keeps the list from growing
-        mGeneratedChallengeCount.removeIf(x -> now - x > GENERATE_CHALLENGE_COUNTER_TTL_MILLIS);
-        if (!mGeneratedChallengeCount.isEmpty()) {
-            mGeneratedChallengeCount.remove(0);
-        }
-        return mGeneratedChallengeCount.size();
-    }
-
-    /**
-     * {@link IBiometricsFace} only supports a single in-flight challenge but there are cases where
-     * two callers both need challenges (e.g. resetLockout right before enrollment).
-     */
-    @Override
-    public void scheduleGenerateChallenge(int sensorId, int userId, @NonNull IBinder token,
-            @NonNull IFaceServiceReceiver receiver, @NonNull String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                try {
-                    receiver.onChallengeGenerated(sensorId, userId, 0L);
-                    return;
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                    return;
-                }
-            }
-            incrementChallengeCount();
-
-            if (isGeneratedChallengeCacheValid()) {
-                Slog.d(TAG, "Current challenge is cached and will be reused");
-                mGeneratedChallengeCache.reuseResult(receiver);
-                return;
-            }
-
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final FaceGenerateChallengeClient client = new FaceGenerateChallengeClient(mContext,
-                    mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId,
-                    opPackageName, mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_UNKNOWN,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext, sSystemClock.millis());
-            mGeneratedChallengeCache = client;
-            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                @Override
-                public void onClientStarted(@NonNull BaseClientMonitor clientMonitor) {
-                    if (client != clientMonitor) {
-                        Slog.e(TAG, "scheduleGenerateChallenge onClientStarted, mismatched client."
-                                + " Expecting: " + client + ", received: " + clientMonitor);
-                    }
-                }
-            });
-        });
-    }
-
-    @Override
-    public void scheduleRevokeChallenge(int sensorId, int userId, @NonNull IBinder token,
-            @NonNull String opPackageName, long challenge) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                return;
-            }
-            final boolean shouldRevoke = decrementChallengeCount() == 0;
-            if (!shouldRevoke) {
-                Slog.w(TAG, "scheduleRevokeChallenge skipped - challenge still in use: "
-                        + mGeneratedChallengeCount);
-                return;
-            }
-
-            Slog.d(TAG, "scheduleRevokeChallenge executing - no active clients");
-            mGeneratedChallengeCache = null;
-
-            final FaceRevokeChallengeClient client = new FaceRevokeChallengeClient(mContext,
-                    mLazyDaemon, token, userId, opPackageName, mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_UNKNOWN,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext);
-            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                @Override
-                public void onClientFinished(@NonNull BaseClientMonitor clientMonitor,
-                        boolean success) {
-                    if (client != clientMonitor) {
-                        Slog.e(TAG, "scheduleRevokeChallenge, mismatched client."
-                                + "Expecting: " + client + ", received: " + clientMonitor);
-                    }
-                }
-            });
-        });
-    }
-
-    @Override
-    public long scheduleEnroll(int sensorId, @NonNull IBinder token,
-            @NonNull byte[] hardwareAuthToken, int userId, @NonNull IFaceServiceReceiver receiver,
-            @NonNull String opPackageName, @NonNull int[] disabledFeatures,
-            @Nullable Surface previewSurface, boolean debugConsent) {
-        final long id = mRequestCounter.incrementAndGet();
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                try {
-                    receiver.onError(2, 0);
-                    return;
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                    return;
-                }
-            }
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            BiometricNotificationUtils.cancelFaceReEnrollNotification(mContext);
-
-            final FaceEnrollClient client = new FaceEnrollClient(mContext, mLazyDaemon, token,
-                    new ClientMonitorCallbackConverter(receiver), userId, hardwareAuthToken,
-                    opPackageName, id, FaceUtils.getLegacyInstance(mSensorId), disabledFeatures,
-                    ENROLL_TIMEOUT_SEC, previewSurface, mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_ENROLL,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext);
-
-            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                @Override
-                public void onClientStarted(@NonNull BaseClientMonitor clientMonitor) {
-                    mBiometricStateCallback.onClientStarted(clientMonitor);
-                }
-
-                @Override
-                public void onBiometricAction(int action) {
-                    mBiometricStateCallback.onBiometricAction(action);
-                }
-
-                @Override
-                public void onClientFinished(@NonNull BaseClientMonitor clientMonitor,
-                        boolean success) {
-                    mBiometricStateCallback.onClientFinished(clientMonitor, success);
-                    if (success) {
-                        // Update authenticatorIds
-                        scheduleUpdateActiveUserWithoutHandler(client.getTargetUserId());
-                    }
-                }
-            });
-        });
-        return id;
-    }
-
-    @Override
-    public void cancelEnrollment(int sensorId, @NonNull IBinder token, long requestId) {
-        mHandler.post(() -> mScheduler.cancelEnrollment(token, requestId));
-    }
-
-    @Override
-    public long scheduleFaceDetect(@NonNull IBinder token,
-            @NonNull ClientMonitorCallbackConverter callback,
-            @NonNull FaceAuthenticateOptions options, int statsClient) {
-        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did you"
-                + "forget to check the supportsFaceDetection flag?");
-    }
-
-    @Override
-    public void cancelFaceDetect(int sensorId, @NonNull IBinder token, long requestId) {
-        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did you"
-                + "forget to check the supportsFaceDetection flag?");
-    }
-
-    @Override
-    public void scheduleAuthenticate(@NonNull IBinder token, long operationId,
-            int cookie, @NonNull ClientMonitorCallbackConverter receiver,
-            @NonNull FaceAuthenticateOptions options, long requestId, boolean restricted,
-            int statsClient, boolean allowBackgroundAuthentication) {
-        mHandler.post(() -> {
-            final int userId = options.getUserId();
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                try {
-                    receiver.onError(1008, 0, 1, 0);
-                    return;
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                    return;
-                }
-            }
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final boolean isStrongBiometric = Utils.isStrongBiometric(mSensorId);
-            final FaceAuthenticationClient client = new FaceAuthenticationClient(mContext,
-                    mLazyDaemon, token, requestId, receiver, operationId, restricted,
-                    options, cookie, false /* requireConfirmation */,
-                    createLogger(BiometricsProtoEnums.ACTION_AUTHENTICATE, statsClient),
-                    mBiometricContext, isStrongBiometric, mLockoutTracker,
-                    mUsageStats, allowBackgroundAuthentication,
-                    Utils.getCurrentStrength(mSensorId));
-            mScheduler.scheduleClientMonitor(client);
-        });
-    }
-
-    @Override
-    public long scheduleAuthenticate(@NonNull IBinder token, long operationId,
-            int cookie, @NonNull ClientMonitorCallbackConverter receiver,
-            @NonNull FaceAuthenticateOptions options, boolean restricted,
-            int statsClient, boolean allowBackgroundAuthentication) {
-        final long id = mRequestCounter.incrementAndGet();
-
-        scheduleAuthenticate(token, operationId, cookie, receiver,
-                options, id, restricted, statsClient, allowBackgroundAuthentication);
-
-        return id;
-    }
-
-    @Override
-    public void cancelAuthentication(int sensorId, @NonNull IBinder token, long requestId) {
-        mHandler.post(() -> mScheduler.cancelAuthenticationOrDetection(token, requestId));
-    }
-
-    @Override
-    public void scheduleRemove(int sensorId, @NonNull IBinder token, int faceId, int userId,
-            @NonNull IFaceServiceReceiver receiver, @NonNull String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                try {
-                    receiver.onError(1, 0);
-                    return;
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                    return;
-                }
-            }
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final FaceRemovalClient client = new FaceRemovalClient(mContext, mLazyDaemon, token,
-                    new ClientMonitorCallbackConverter(receiver), faceId, userId, opPackageName,
-                    FaceUtils.getLegacyInstance(mSensorId), mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_REMOVE,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext, mAuthenticatorIds);
-            mScheduler.scheduleClientMonitor(client, mBiometricStateCallback);
-        });
-    }
-
-    @Override
-    public void scheduleRemoveAll(int sensorId, @NonNull IBinder token, int userId,
-            @NonNull IFaceServiceReceiver receiver, @NonNull String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                try {
-                    receiver.onError(1, 0);
-                    return;
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                    return;
-                }
-            }
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            // For IBiometricsFace@1.0, remove(0) means remove all enrollments
-            final FaceRemovalClient client = new FaceRemovalClient(mContext, mLazyDaemon, token,
-                    new ClientMonitorCallbackConverter(receiver), 0 /* faceId */, userId,
-                    opPackageName,
-                    FaceUtils.getLegacyInstance(mSensorId), mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_REMOVE,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext, mAuthenticatorIds);
-            mScheduler.scheduleClientMonitor(client, mBiometricStateCallback);
-        });
-    }
-
-    @Override
-    public void scheduleResetLockout(int sensorId, int userId, @NonNull byte[] hardwareAuthToken) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-            }
-            if (getEnrolledFaces(sensorId, userId).isEmpty()) {
-                Slog.w(TAG, "Ignoring lockout reset, no templates enrolled for user: " + userId);
-                return;
-            }
-
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final FaceResetLockoutClient client = new FaceResetLockoutClient(mContext,
-                    mLazyDaemon, userId, mContext.getOpPackageName(), mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_UNKNOWN,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext, hardwareAuthToken);
-            mScheduler.scheduleClientMonitor(client, mBiometricStateCallback);
-        });
-    }
-
-    @Override
-    public void scheduleSetFeature(int sensorId, @NonNull IBinder token, int userId, int feature,
-            boolean enabled, @NonNull byte[] hardwareAuthToken,
-            @NonNull IFaceServiceReceiver receiver, @NonNull String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                return;
-            }
-            final List<Face> faces = getEnrolledFaces(sensorId, userId);
-            if (faces.isEmpty()) {
-                Slog.w(TAG, "Ignoring setFeature, no templates enrolled for user: " + userId);
-                return;
-            }
-
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final int faceId = faces.get(0).getBiometricId();
-            final FaceSetFeatureClient client = new FaceSetFeatureClient(mContext,
-                    mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId,
-                    opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext),
-                    mBiometricContext,
-                    feature, enabled, hardwareAuthToken, faceId);
-            mScheduler.scheduleClientMonitor(client, mBiometricStateCallback);
-        });
-    }
-
-    @Override
-    public void scheduleGetFeature(int sensorId, @NonNull IBinder token, int userId, int feature,
-            @Nullable ClientMonitorCallbackConverter listener, @NonNull String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindService(mCurrentUserId);
-                if (listener != null) {
-                    try {
-                        listener.onError(1008, 0, 1, 0);
-                        return;
-                    } catch (RemoteException e) {
-                        e.printStackTrace();
-                        return;
-                    }
-                }
-                return;
-            }
-            final List<Face> faces = getEnrolledFaces(sensorId, userId);
-            if (faces.isEmpty()) {
-                Slog.w(TAG, "Ignoring getFeature, no templates enrolled for user: " + userId);
-                return;
-            }
-
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final int faceId = faces.get(0).getBiometricId();
-            final FaceGetFeatureClient client = new FaceGetFeatureClient(mContext, mLazyDaemon,
-                    token, listener, userId, opPackageName, mSensorId,
-                    BiometricLogger.ofUnknown(mContext), mBiometricContext,
-                    feature, faceId);
-            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                @Override
-                public void onClientFinished(
-                        @NonNull BaseClientMonitor clientMonitor, boolean success) {
-                    if (success && feature == BiometricFaceConstants.FEATURE_REQUIRE_ATTENTION) {
-                        final int settingsValue = client.getValue() ? 1 : 0;
-                        Slog.d(TAG, "Updating attention value for user: " + userId
-                                + " to value: " + settingsValue);
-                        Settings.Secure.putIntForUser(mContext.getContentResolver(),
-                                Settings.Secure.FACE_UNLOCK_ATTENTION_REQUIRED,
-                                settingsValue, userId);
-                    }
-                }
-            });
-        });
-    }
-
-    private void scheduleInternalCleanup(int userId,
-            @Nullable ClientMonitorCallback callback) {
-        mHandler.post(() -> {
-            scheduleUpdateActiveUserWithoutHandler(userId);
-
-            final FaceInternalCleanupClient client = new FaceInternalCleanupClient(mContext,
-                    mLazyDaemon, userId, mContext.getOpPackageName(), mSensorId,
-                    createLogger(BiometricsProtoEnums.ACTION_ENUMERATE,
-                            BiometricsProtoEnums.CLIENT_UNKNOWN),
-                    mBiometricContext,
-                    FaceUtils.getLegacyInstance(mSensorId), mAuthenticatorIds);
-            mScheduler.scheduleClientMonitor(client, new ClientMonitorCompositeCallback(callback,
-                    mBiometricStateCallback));
-        });
-    }
-
-    @Override
-    public void scheduleInternalCleanup(int sensorId, int userId,
-            @Nullable ClientMonitorCallback callback) {
-        scheduleInternalCleanup(userId, mBiometricStateCallback);
-    }
-
-    @Override
-    public void scheduleInternalCleanup(int sensorId, int userId,
-            @Nullable ClientMonitorCallback callback, boolean favorHalEnrollments) {
-        scheduleInternalCleanup(userId, mBiometricStateCallback);
-    }
-
-    @Override
-    public void startPreparedClient(int sensorId, int cookie) {
-        mHandler.post(() -> {
-            mScheduler.startPreparedClient(cookie);
-        });
-    }
-
-    @Override
-    public void dumpProtoState(int sensorId, ProtoOutputStream proto,
-            boolean clearSchedulerBuffer) {
-        final long sensorToken = proto.start(SensorServiceStateProto.SENSOR_STATES);
-
-        proto.write(SensorStateProto.SENSOR_ID, mSensorProperties.sensorId);
-        proto.write(SensorStateProto.MODALITY, SensorStateProto.FACE);
-        proto.write(SensorStateProto.CURRENT_STRENGTH,
-                Utils.getCurrentStrength(mSensorProperties.sensorId));
-        proto.write(SensorStateProto.SCHEDULER, mScheduler.dumpProtoState(clearSchedulerBuffer));
-
-        for (UserInfo user : UserManager.get(mContext).getUsers()) {
-            final int userId = user.getUserHandle().getIdentifier();
-
-            final long userToken = proto.start(SensorStateProto.USER_STATES);
-            proto.write(UserStateProto.USER_ID, userId);
-            proto.write(UserStateProto.NUM_ENROLLED, FaceUtils.getLegacyInstance(mSensorId)
-                    .getBiometricsForUser(mContext, userId).size());
-            proto.end(userToken);
-        }
-
-        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_HARDWARE_AUTH_TOKEN,
-                mSensorProperties.resetLockoutRequiresHardwareAuthToken);
-        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_CHALLENGE,
-                mSensorProperties.resetLockoutRequiresChallenge);
-
-        proto.end(sensorToken);
-    }
-
-    @Override
-    public void dumpProtoMetrics(int sensorId, FileDescriptor fd) {
-    }
-
-    @Override
-    public void dumpInternal(int sensorId, PrintWriter pw) {
-        PerformanceTracker performanceTracker =
-                PerformanceTracker.getInstanceForSensorId(mSensorId);
-
-        JSONObject dump = new JSONObject();
-        try {
-            dump.put("service", TAG);
-
-            JSONArray sets = new JSONArray();
-            for (UserInfo user : UserManager.get(mContext).getUsers()) {
-                final int userId = user.getUserHandle().getIdentifier();
-                final int c = FaceUtils.getLegacyInstance(mSensorId)
-                        .getBiometricsForUser(mContext, userId).size();
-                JSONObject set = new JSONObject();
-                set.put("id", userId);
-                set.put("count", c);
-                set.put("accept", performanceTracker.getAcceptForUser(userId));
-                set.put("reject", performanceTracker.getRejectForUser(userId));
-                set.put("acquire", performanceTracker.getAcquireForUser(userId));
-                set.put("lockout", performanceTracker.getTimedLockoutForUser(userId));
-                set.put("permanentLockout", performanceTracker.getPermanentLockoutForUser(userId));
-                // cryptoStats measures statistics about secure face transactions
-                // (e.g. to unlock password storage, make secure purchases, etc.)
-                set.put("acceptCrypto", performanceTracker.getAcceptCryptoForUser(userId));
-                set.put("rejectCrypto", performanceTracker.getRejectCryptoForUser(userId));
-                set.put("acquireCrypto", performanceTracker.getAcquireCryptoForUser(userId));
-                sets.put(set);
-            }
-
-            dump.put("prints", sets);
-        } catch (JSONException e) {
-            Slog.e(TAG, "dump formatting failure", e);
-        }
-        pw.println(dump);
-        pw.println("HAL deaths since last reboot: " + performanceTracker.getHALDeathCount());
-
-        mScheduler.dump(pw);
-        mUsageStats.print(pw);
-    }
-
-    private void scheduleLoadAuthenticatorIds() {
-        // Note that this can be performed on the scheduler (as opposed to being done immediately
-        // when the HAL is (re)loaded, since
-        // 1) If this is truly the first time it's being performed (e.g. system has just started),
-        //    this will be run very early and way before any applications need to generate keys.
-        // 2) If this is being performed to refresh the authenticatorIds (e.g. HAL crashed and has
-        //    just been reloaded), the framework already has a cache of the authenticatorIds. This
-        //    is safe because authenticatorIds only change when A) new template has been enrolled,
-        //    or B) all templates are removed.
-        mHandler.post(() -> {
-            for (UserInfo user : UserManager.get(mContext).getAliveUsers()) {
-                final int targetUserId = user.id;
-                if (!mAuthenticatorIds.containsKey(targetUserId)) {
-                    scheduleUpdateActiveUserWithoutHandler(targetUserId);
-                }
-            }
-        });
-    }
-
-    /**
-     * Schedules the {@link FaceUpdateActiveUserClient} without posting the work onto the handler.
-     * Many/most APIs are user-specific. However, the HAL requires explicit "setActiveUser"
-     * invocation prior to authenticate/enroll/etc. Thus, internally we usually want to schedule
-     * this operation on the same lambda/runnable as those operations so that the ordering is
-     * correct.
-     */
-    private void scheduleUpdateActiveUserWithoutHandler(int targetUserId) {
-        final boolean hasEnrolled = !getEnrolledFaces(mSensorId, targetUserId).isEmpty();
-        final FaceUpdateActiveUserClient client = new FaceUpdateActiveUserClient(mContext,
-                mLazyDaemon, targetUserId, mContext.getOpPackageName(), mSensorId,
-                createLogger(BiometricsProtoEnums.ACTION_UNKNOWN,
-                        BiometricsProtoEnums.CLIENT_UNKNOWN),
-                mBiometricContext, hasEnrolled, mAuthenticatorIds);
-        mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-            @Override
-            public void onClientFinished(@NonNull BaseClientMonitor clientMonitor,
-                    boolean success) {
-                if (success) {
-                    mCurrentUserId = targetUserId;
-                } else {
-                    Slog.w(TAG, "Failed to change user, still: " + mCurrentUserId);
-                }
-            }
-        });
-    }
-
-    public class SenseServiceConnection implements ServiceConnection {
-        private int mUserId;
-
-        public SenseServiceConnection(int userId) {
-            mUserId = userId;
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            Slog.d(TAG, "Service connected : " + mUserId);
-            ISenseService senseService = ISenseService.Stub.asInterface(service);
-            if (senseService != null) {
-                synchronized (mServices) {
-                    try {
-                        senseService.setCallback(mHalResultController);
-                        mServices.put(mUserId, senseService);
-                        mHandler.post(() -> {
-                            updateSchedule();
-                        });
-                    } catch (RemoteException e) {
-                        e.printStackTrace();
-                    }
-                    mIsBinding = false;
-                }
-            }
-        }
-
-        public void updateSchedule() {
-            scheduleInternalCleanup(mUserId, null);
-            scheduleGetFeature(mSensorId, new Binder(), mUserId, 1, null, mContext.getOpPackageName());
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName className) {
-            Slog.d(TAG, "Service disconnected : " + mUserId);
-            mServices.remove(mUserId);
-            mIsBinding = false;
-            if (mUserId == mCurrentUserId) {
-                mHandler.post(() -> {
-                    updateResetSchedule();
-                });
-            }
-            mContext.unbindService(this);
-        }
-
-        public void updateResetSchedule() {
-            BaseClientMonitor client = mScheduler.getCurrentClient();
-            if (client != null && (client instanceof ErrorConsumer)) {
-                ErrorConsumer errorConsumer = (ErrorConsumer) client;
-                errorConsumer.onError(5, 0);
-            }
-            bindService(mUserId);
-            mScheduler.recordCrashState();
-            mScheduler.reset();
-        }
-    }
-
-    private boolean isServiceEnabled() {
-        PackageManager pm = mContext.getPackageManager();
-        Intent intent = new Intent(BIND_SENSE_ACTION);
-        intent.setClassName(PACKAGE_NAME, SERVICE_NAME);
-        ResolveInfo info = pm.resolveService(intent, 131072);
-        if (info != null && info.serviceInfo.isEnabled()) {
-            return true;
-        }
-        return false;
-    }
-
-    private ISenseService getService(int userId) {
-        if (userId == -10000) {
-            scheduleUpdateActiveUserWithoutHandler(ActivityManager.getCurrentUser());
-        }
-        return mServices.get(mCurrentUserId);
-    }
-
-    public boolean bindService(int userId) {
-        Slog.d(TAG, "bindService " + userId);
-        if (!isServiceEnabled()) {
-            Slog.d(TAG, "Service disabled");
-            return false;
-        } else if (mIsBinding) {
-            Slog.d(TAG, "Service is binding");
-            return true;
-        } else {
-            if (userId != -10000 && getService(userId) == null) {
-                try {
-                    Intent intent = new Intent(BIND_SENSE_ACTION);
-                    intent.setClassName(PACKAGE_NAME, SERVICE_NAME);
-                    boolean result = mContext.bindServiceAsUser(intent, new SenseServiceConnection(userId), 1, UserHandle.of(userId));
-                    if (result) {
-                        mIsBinding = true;
-                    }
-                    return result;
-                } catch (SecurityException e) {
-                    e.printStackTrace();
-                }
-            }
-            return false;
-        }
-    }
-
-    private BiometricLogger createLogger(int statsAction, int statsClient) {
-        return new BiometricLogger(mContext, BiometricsProtoEnums.MODALITY_FACE,
-                statsAction, statsClient, mAuthenticationStatsCollector);
-    }
-
-    /**
-     * Sends a debug message to the HAL with the provided FileDescriptor and arguments.
-     */
-    public void dumpHal(int sensorId, @NonNull FileDescriptor fd, @NonNull String[] args) { }
-
-    void setTestHalEnabled(boolean enabled) {
-        mTestHalEnabled = enabled;
-    }
-
-    @NonNull
-    @Override
-    public ITestSession createTestSession(int sensorId, @NonNull ITestSessionCallback callback,
-            @NonNull String opPackageName) {
-        return new BiometricTestSessionImpl(mContext, mSensorId, callback, this,
-                mHalResultController);
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/SenseUtils.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/SenseUtils.java
deleted file mode 100644
index 9e49fa1e7848..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/SenseUtils.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.os.SystemProperties;
-
-import java.util.ArrayList;
-
-public class SenseUtils {
-
-    public static boolean canUseProvider() {
-        return SystemProperties.getBoolean("ro.face.sense_service", false);
-    }
-
-    public static ArrayList<Byte> toByteArrayList(byte[] in) {
-        if (in == null) {
-            return null;
-        }
-        ArrayList<Byte> out = new ArrayList<>(in.length);
-        for (byte c : in) {
-            out.add(Byte.valueOf(c));
-        }
-        return out;
-    }
-
-    public static byte[] toByteArray(ArrayList<Byte> in) {
-        if (in == null) {
-            return null;
-        }
-        byte[] out = new byte[in.size()];
-        for (int i = 0; i < in.size(); i++) {
-            out[i] = in.get(i).byteValue();
-        }
-        return out;
-    }
-
-    public static int[] toIntArray(ArrayList<Integer> in) {
-        if (in == null) {
-            return null;
-        }
-        int[] out = new int[in.size()];
-        for (int i = 0; i < in.size(); i++) {
-            out[i] = in.get(i).intValue();
-        }
-        return out;
-    }
-}
\ No newline at end of file
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/sense/TestHal.java b/services/core/java/com/android/server/biometrics/sensors/face/sense/TestHal.java
deleted file mode 100644
index 0499bc51ede6..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/sense/TestHal.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- * Copyright (C) 2023 Paranoid Android
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.biometrics.sensors.face.sense;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.content.Context;
-import android.hardware.biometrics.face.V1_0.FaceError;
-import android.hardware.biometrics.face.V1_0.OptionalBool;
-import android.hardware.biometrics.face.V1_0.OptionalUint64;
-import android.hardware.biometrics.face.V1_0.Status;
-import android.hardware.face.Face;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.sensors.face.FaceUtils;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import vendor.aospa.biometrics.face.ISenseService;
-import vendor.aospa.biometrics.face.ISenseServiceReceiver;
-
-public class TestHal extends ISenseService.Stub {
-    private static final String TAG = "face.hidl.TestHal";
-
-    @NonNull
-    private final Context mContext;
-    private final int mSensorId;
-
-    @Nullable
-    private ISenseServiceReceiver mCallback;
-    private int mUserId;
-
-    TestHal(@NonNull Context context, int sensorId) {
-        mContext = context;
-        mSensorId = sensorId;
-    }
-
-    @Override
-    public void setCallback(ISenseServiceReceiver clientCallback) {
-        mCallback = clientCallback;
-    }
-
-    @Override
-    public long generateChallenge(int challengeTimeoutSec) {
-        Slog.w(TAG, "generateChallenge");
-        return 0L;
-    }
-
-    @Override
-    public void enroll(byte[] hat, int timeoutSec, int[] disabledFeatures) {
-        Slog.w(TAG, "enroll");
-    }
-
-    @Override
-    public int revokeChallenge() {
-        return 0;
-    }
-
-    @Override
-    public void setFeature(int feature, boolean enabled, byte[] token, int faceId) { }
-
-    @Override
-    public boolean getFeature(int feature, int faceId) {
-        return false;
-    }
-
-    @Override
-    public int getFeatureCount() throws RemoteException {
-        return 0;
-    }
-
-    @Override
-    public int getAuthenticatorId() {
-        return 0;
-    }
-
-    @Override
-    public void cancel() throws RemoteException {
-        if (mCallback != null) {
-            mCallback.onError(0 /* deviceId */, 0 /* vendorCode */);
-        }
-    }
-
-    @Override
-    public int enumerate() throws RemoteException {
-        Slog.w(TAG, "enumerate");
-        if (mCallback != null) {
-            mCallback.onEnumerate(new int[0], 0 /* userId */);
-        }
-        return 0;
-    }
-
-    @Override
-    public void remove(int faceId) throws RemoteException {
-        Slog.w(TAG, "remove");
-        if (mCallback != null) {
-            if (faceId == 0) {
-                List<Face> faces = FaceUtils.getInstance(mSensorId).getBiometricsForUser(mContext, mUserId);
-                if (faces.size() <= 0) {
-                    mCallback.onError(6, 0);
-                    return;
-                }
-                int[] faceIds = new int[faces.size()];
-                for (int i = 0; i < faces.size(); i++) {
-                    Face face = faces.get(i);
-                    faceIds[i] = face.getBiometricId();
-                }
-
-                mCallback.onRemoved(faceIds, mUserId);
-            } else {
-                mCallback.onRemoved(new int[]{faceId}, mUserId);
-            }
-        }
-    }
-
-    @Override
-    public void authenticate(long operationId) {
-        Slog.w(TAG, "authenticate");
-    }
-
-    @Override
-    public void resetLockout(byte[] hat) {
-        Slog.w(TAG, "resetLockout");
-    }
-
-}
diff --git a/services/core/java/com/android/server/crdroid/CustomDeviceConfigService.java b/services/core/java/com/android/server/crdroid/CustomDeviceConfigService.java
deleted file mode 100644
index 8d8d18f188af..000000000000
--- a/services/core/java/com/android/server/crdroid/CustomDeviceConfigService.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2023 The PixelExperience Project
- * SPDX-License-Identifier: Apache-2.0
- */
-
-package com.android.server.crdroid;
-
-import android.content.Context;
-import com.android.server.SystemService;
-
-import com.android.internal.util.crdroid.DeviceConfigUtils;
-
-public class CustomDeviceConfigService extends SystemService {
-
-    private static final String TAG = "CustomDeviceConfigService";
-
-    private final Context mContext;
-
-    public CustomDeviceConfigService(Context context) {
-        super(context);
-        mContext = context;
-    }
-
-    @Override
-    public void onStart() {
-    }
-
-    @Override
-    public void onBootPhase(int phase) {
-        if (phase == PHASE_BOOT_COMPLETED) {
-            DeviceConfigUtils.setDefaultProperties(null, null);
-        }
-    }
-}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 8dacbd252ecb..185b83d7001c 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -129,7 +129,6 @@ import com.android.server.connectivity.PacProxyService;
 import com.android.server.contentcapture.ContentCaptureManagerInternal;
 import com.android.server.coverage.CoverageService;
 import com.android.server.cpu.CpuMonitorService;
-import com.android.server.crdroid.CustomDeviceConfigService;
 import com.android.server.criticalevents.CriticalEventLog;
 import com.android.server.devicepolicy.DevicePolicyManagerService;
 import com.android.server.devicestate.DeviceStateManagerService;
@@ -2666,11 +2665,6 @@ public final class SystemServer implements Dumpable {
             mSystemServiceManager.startService(BackgroundInstallControlService.class);
             t.traceEnd();
 
-            // CustomDeviceConfigService
-            t.traceBegin("StartCustomDeviceConfigService");
-            mSystemServiceManager.startService(CustomDeviceConfigService.class);
-            t.traceEnd();
-
             if (context.getResources().getBoolean(
                     com.android.internal.R.bool.config_mockOplusLinearmotorVibratorService)) {
                 t.traceBegin("StartLinearmotorVibratorService");
